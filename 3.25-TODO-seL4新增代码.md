

# head.S

.section 定义内存段。.boot.text：

![image-20220325171923329](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220325171923329.png)

关于ax，很多地方都出现，此处也保留。

.global关键字用来让一个符号对连接器可见，可以供其他连接对象模块使用。
.global _start 让_start符号成为可见的标示符，这样连接器就知道跳转到程序中的什么地方并开始执行。linux寻找这个 _start标签作为程序的默认进入点。

.extern kernel_stack_alloc来自kernel/src/kernel/stack.c

.extern __global_pointer$ 栈指针？它好像在kernel/src/arch/arm/common_arm.lds被定义。[Linux下的lds链接脚本详解](https://www.cnblogs.com/li-hao/p/4107964.html)。

head.S文件：

```head.S
.section 




```

# common_loongarch.lds

[Linux下的lds链接脚本详解](https://www.cnblogs.com/li-hao/p/4107964.html)。总之，输入多个文件，链接成一个elf文件

[对GNU的.lds连接脚本文件的分析 - Linux文档专区-Chinaunix](http://bbs.chinaunix.net/forum.php?mod=viewthread&tid=1963790&highlight=lds%2B%BD%C5%B1%BE)。

这里面很多头文件怎么找？

#include<config.h>但是在config.h中并没有看到很有用的信息。

![image-20220326000033707](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326000033707.png)

#include <hardware.h>??

通过find命令，看到：

![image-20220326104353012](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326104353012.png)

在cmakelists.txt中，include了相应架构下的内容。结合上文，hardware.h应该是指

![image-20220326104249867](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326104249867.png)

如果将这4个hardware.h改名，在编译平台相关代码即ninja的时候，会先报错：找不到arch/machine/hardware.h。此处说明arch/object/structures.h引用了arch/machine/hardware.h头文件。

![image-20220326154140407](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326154140407.png)

将arch/machine/hardware.h恢复。再次ninja，找不到mode/hardware.h。此处说明arch/machine/hardware.h 引用了64/mode/hardware.h。

![image-20220326154455174](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326154455174.png)

将64/mode/hardware.h恢复。再次ninja，找不到hardware.h。此处说明/include/machine.h下引用了/include/hardware.h

![image-20220326154942420](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326154942420.png)

事实证明，32/mode/hardware.h未被调用。此处无用。

因此，直接hardware.h，应该对应：

![image-20220326161711007](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326161711007.png)

即

![image-20220326162012785](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326162012785.png)

machine/hardware.h，应该对应：

![image-20220326162124350](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326162124350.png)

即

![image-20220326162249044](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326162249044.png)

mode/hardware.h，应该对应：

![image-20220326162313282](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326162313282.png)

即

![image-20220326162337966](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326162337966.png)

#include <sel4/plat/api/constants.h>???

![image-20220326171610761](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326171610761.png)

对应：

![image-20220326172156969](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326172156969.png)

即：

![image-20220326172218258](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326172218258.png)





```
OUTPUT_ARCH(loongarch)//输出架构
ENTRY(_start)//指定输出可执行文件的起始代码段为_start


```













