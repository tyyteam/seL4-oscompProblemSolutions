# 参考

左侧是起始地址，右侧是地址长度

![image-20220504102331765](images/5.4-TODO-uart%E7%9B%B8%E5%85%B3.assets/image-20220504102331765.png)

uart上有很多寄存器，类似于如下方式基址加偏移

![image-20220504102521576](images/5.4-TODO-uart%E7%9B%B8%E5%85%B3.assets/image-20220504102521576.png)



A2~0是寄存器号，8个寄存器

![image-20220504102805084](images/5.4-TODO-uart%E7%9B%B8%E5%85%B3.assets/image-20220504102805084.png)





读与写

![image-20220504103111476](images/5.4-TODO-uart%E7%9B%B8%E5%85%B3.assets/image-20220504103111476.png)



初始化，设置波特率等

![image-20220504104006759](images/5.4-TODO-uart%E7%9B%B8%E5%85%B3.assets/image-20220504104006759.png)

![image-20220504104808870](images/5.4-TODO-uart%E7%9B%B8%E5%85%B3.assets/image-20220504104808870.png)



![image-20220504104922762](images/5.4-TODO-uart%E7%9B%B8%E5%85%B3.assets/image-20220504104922762.png)

## 初始化

要设置lcr寄存器，打开lcr的开关，lcr是复用的，有中断和波特率的功能。DLL和DLM分别存储8位。

![image-20220508102439323](images/5.4-TODO-uart%E7%9B%B8%E5%85%B3.assets/image-20220508102439323.png)



其他设置，数据位用8位，1bit停止位，没有奇偶校验

![image-20220508102936887](images/5.4-TODO-uart%E7%9B%B8%E5%85%B3.assets/image-20220508102936887.png)

# 思考

在kernel/src/arch/loongarch/machine/io.c下，是kerneldebug信息输入输出函数的接口，考虑将其中sbi的相关函数修改成uart的操作。

需要打开debug_build，printing。在machine/io.h下被调用。



uart.h

![image-20220504115505215](images/5.4-TODO-uart%E7%9B%B8%E5%85%B3.assets/image-20220504115505215.png)



龙芯3A5000手册中有uart内容。

mips下的文件

![image-20220504141433361](images/5.4-TODO-uart%E7%9B%B8%E5%85%B3.assets/image-20220504141433361.png)



## 初始化与elfloader调用

关于brcm,bcm2835-aux-uart的初始化

* tools/seL4/elfloader-tool/src/drivers/uart/bcm-uart.c，注册brcm,bcm2835-aux-uart，并初始化。
  * 在tools/seL4/elfloader-tool/include/drivers/common.h有struct dtb_match_table定义。
  * tools/seL4/elfloader-tool/src/drivers/driver.c的table_has_match检测是否匹配字符串。
  
* tools/seL4/elfloader-tool/include/drivers/uart.h，有elfloader_uart_ops的相关定义。
  * 对应着输出字符。
  
* tools/seL4/elfloader-tool/include/drivers/common.h，有elfloader_driver的定义。

* ELFLOADER_DRIVER将struct elfloader_driver的变量放进去。

* kernel/tools/hardware/outputs/elfloader.py会根据dts生成头文件，该头文件与elfloader相关。

* tools/seL4/elfloader-tool/src/drivers/driver.c中init_device函数会调用uart的init函数。init_device被后面的initialise_devices调用。
  * 
  * elfloader_device，保存了匹配字符串，region_bases，elfloader_driver* drv。

* tools/seL4/elfloader-tool/src/drivers/uart/common.c中的plat_console_putchar会调用uart的打印函数。arch_write_char调用plat_console_putchar，此处是弱符号函数，如果外部不重新定义，则调用weak函数。tools/seL4/elfloader-tool/src/printf.c的printf会调用arch_write_char。

* rpi3.dts的serial@7e215040，它对应build_rpi下的kernel/gen_headers/plat/machine/devices_gen.h中的内容，但是具体的物理地址改变了？

  * 7e215040对应着paddr = 0x3f215000，因为其soc中有映射关系

    ![image-20220512171942187](images/5.4-TODO-uart%E7%9B%B8%E5%85%B3.assets/image-20220512171942187.png)

    




ricv的相关调用

* tools/seL4/elfloader-tool/src/arch-riscv/console.c调用了sbi_console_putchar，该函数在tools/seL4/elfloader-tool/include/arch-riscv/sbi.h
* sbi并不需要初始化uart设备。

## 关于dts 与 python文件的关联，uart0基地址如何获取？

根据qemu源码改龙芯dts。

如何从qemu导出dts？输入如下命令，注意此处的qemu-system-loongarch64直接下载老师编译好的程序。

```
./qemu-system-loongarch64 -M virt,dumpdtb=3A5000.dtb -m 4G -smp 1 -bios ./loongarch_bios_0310_debug.bin -kernel ./vmlinux -initrd ./busybox-rootfs.img -append "root=/dev/ram console=ttyS0,115200 rdinit=/init" -vga none -nographic

dtc -o 3A5000.dts -O dts -I dtb 3A5000.dtb
```



在kernel/tools/hardware/outputs/yaml.py的get_kernel_devices，打印循环中的rule和get_regions可以看到uart_pptr的内容。基本没问题？

## tools下region_bases的问题

rpi3的build文件夹下有相应的生成文件elfloader/gen_headers/devices_gen.h。

kernel/tools/hardware/outputs/**elfloader.py下的run函数**有被执行？无。

kernel/tools/hardware_gen.py的main函数调用**elfloader.py下的run函数**：OUTPUTS[t].run(parsed_dt, hw_yaml, cfg, args)，main函数被92行的else分支调用。

* cfg

  * KernelSel4Arch√

  * KernelPaddrUserTop----0x80 0000 0000，修改为1<<47

* dtb√

* 打印arg_dict

![image-20220512211442790](images/5.4-TODO-uart%E7%9B%B8%E5%85%B3.assets/image-20220512211442790.png)

* 打印OUTPUTS

![image-20220512211817968](images/5.4-TODO-uart%E7%9B%B8%E5%85%B3.assets/image-20220512211817968.png)

sorted的顺序：

![image-20220512211944473](images/5.4-TODO-uart%E7%9B%B8%E5%85%B3.assets/image-20220512211944473.png)

* 此处elfloader的值是false?

![image-20220512212716761](images/5.4-TODO-uart%E7%9B%B8%E5%85%B3.assets/image-20220512212716761.png)

* 这个地方会被执行两次，第一次init-build时候false没问题。第二次，arm在ninja执行时，elfloader为true，但是我们为false。

  * arm的elfloader=True, elfloader_out=<_io.TextIOWrapper name='/home/lqt/桌面/oscomp/sel4test/build_rpi/elfloader/gen_headers/devices_gen.h' mode='w' encoding='UTF-8'>
  * 但是我们的elfloader=False, elfloader_out=None

  * tools/seL4/elfloader-tool/CMakeLists.txt中也会调用${PYTHON3} ${HARDWARE_GEN_PATH}



## kernel下uart的问题

调用printf函数，进入kernel/include/machine/io.h文件的printf()

* printf调用kernel/src/machine/io.c的impl_kvprintf
* impl_kvprintf调用kernel/src/machine/io.c的vprintf
* vprintf调用kernel/src/machine/io.c的printf_core
* 





# 修改

内核部分：

* 添加kernel/src/drivers/serial/loongson3A5000-uart.c文件。kernel/include/drivers/uart.h会调用架构相关的uart操作函数。可以操作uart_console_putchar，uart_drv_getchar两个函数。
* 在kernel/src/arch/loongarch/machine/io.c下，在kernel_putDebugChar调用uart_console_putchar，在kernel_getDebugChar调用uart_drv_getchar函数。该函数又会被kernel/include/machine/io.h的kernel_putchar和putchar调用。kernel_putchar被kernel/src/api/syscall.c的handleUnknownSyscall调用。putchar被puts调用或被直接使用。
* 添加支持：kernel/src/drivers/serial/config.cmake。
* 添加kernel/tools/dts/3A5000.dts文件。
* kernel/tools/hardware.yml添加支持。
* 在kernel/CMakeLists.txt加了string(APPEND common_flags " -Wno-error=array-bounds")

elfloader部分：

* 在tools/seL4/elfloader-tool/src/arch-loongarch/boot.c的main函数中，首先初始化设备。initialise_devices。
* 删去文件tools/seL4/elfloader-tool/src/arch-loongarch/console.c，我们使用原始的弱符号的plat_console_putchar。
* 在tools/seL4/elfloader-tool/src/drivers/uart/下新建文件：loongson3A5000-uart.c，注意unit8_t。





参考：

* tools/seL4/elfloader-tool/src/drivers/uart/bcm-uart.c
* 在kernel/src/drivers/config.cmake中，会比较已有字符串列表compatibility_strings，因此需要向字符串列表添加龙芯支持。
  * kernel/config.cmake中，file(READ "${compatibility_outfile}" compatibility_strings)，从compatibility_outfile读出变量。
  * kernel/config.cmake中，99行设置了输出文件compatibility_outfile的路径，在build的kernel下
  * 



待修改：

？添加支持：kernel/tools/hardware.yml

/home/lqt/files/oscomp/sel4test/kernel/include/arch/loongarch/arch/64/mode/hardware.h的**KDEV_BASE**

