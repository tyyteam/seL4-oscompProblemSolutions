# Faults

## Fault的类型
- 由CPU自身产生：在指令执行过程中发生异常
- 由硬件产生：由一些硬件异常引起
- 由seL4内核产生：在当前线程遇到异常（教程讲的都是由内核产生的faults）
	1. Cap fault
	2. VM fault
	3. Unknown Syscall fault
	4. Debug fault

## Fault handling如何工作？
1. 在seL4中，当线程产生了Fault，内核会阻塞该线程然后试图通过一个特定的endpoint发送一条消息，这个endpoint叫做“fault handler” endpoint；一个线程只能拥有一个这种endpoint，但它和其它普通的endpoint的新建和管理操作都是相同的
2. 在“fault handler” endpoint另一端的是“fault handler”，内核期望fault handler处理好异常然后告诉内核可以继续安全地运行发生异常的线程了。为了让内核再次唤醒之前发生错误的线程，fault handler可以选择以下方式之一：
	- 在fault handler endpoint上调用`seL4_Reply()`，并且让`seL4_MessageInfo_t`的`label`字段设置为0；
	- 直接调用`seL4_TCB_Resume()`让内核重启之前发生错误的线程

Note：
- 内核作为endpoint的发送者，fault handler作为endpoint的接收者
- 如果在reply的时候，fault handler在message registers中放了一些信息，内核会把这些消息解释为某些特定参数，详见manual中reply message format部分
- 如果fault handler没有处理好异常，那么重启发生错误线程只会让内核再次产生错误，再次进行处理
- 如果某个线程出现了fault，而没有对应的线程来处理fault，那么内核就会把这个出错的线程挂起




