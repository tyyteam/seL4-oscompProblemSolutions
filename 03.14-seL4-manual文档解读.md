# **seL4-manual解读**

## **1.介绍**

seL4微内核是一种操作系统内核，旨在为各种应用程序域中的系统提供安全、安全、可靠的基础，它仅向应用程序提供少量服务（比如创建和管理虚拟地址空间、线程、进程间通信-IPC）。seL4大约8700行C代码，其完整性和保密性得到了证明(https://github.com/seL4/l4v)。微内核也有助于对最坏情况执行时间进行统筹分析。

manual从用户角度描述seL4内核API，首先概述seL4的设计模式，然后介绍seL4向用户空间开放的高级API。

文档描述并不保证严格符合seL4的真实行为，如有确定内核在特定环境下的精确行为的需求，应参考seL4抽象规范（seL4 abstract specification）(https://www.sel4.systems/Info/Docs/seL4-spec.pdf)，该规范是seL4内核的正式描述。

## **2.内核服务和对象**

微内核提供了有限的服务原语。更复杂的服务可以作为应用程序用这些原语实现。这样可以不增加特权模式代码以及复杂性，还能扩展功能，从而支持各种应用程序域的大量服务。
**注意，只有在内核配置为MCS（mixed-criticality system）支持时，一些服务才可用。**

seL4提供以下基本服务：

1. **Threads 线程**是支持软件运行的CPU执行的抽象;
2. **Scheduling contexts 调度上下文**(仅MCS配置下)是CPU执行时间的抽象。
3. **Address spaces 地址空间**是虚拟内存空间，每个地址空间包含一个应用程序。应用程序只能访问地址空间中的内存;
4. **Inter-process communication 通过端点的进程间通信**(IPC)允许线程使用消息传递进行通信;
5. **Reply objects 应答对象**(仅MCS配置下)用于存储一次性应答功能，在消息传递期间由接收方提供。
6. **Notifications 通知**提供了一种类似于二进制信号量的非阻塞信号机制。
7. **Device primitives 设备原语**允许将设备驱动程序实现为非特权应用程序。内核通过IPC消息导出硬件设备中断;
8. **Capability spaces 权限空间**存储对内核服务的权限(即访问权限)及其记录信息。

本章概述了这些服务，描述了用户空间应用程序如何访问内核对象，以及如何创建新的对象。
### **2.1基于权限的访问控制**

seL4微内核提供了一个基于功能的访问控制模型。访问控制控制所有内核服务;为了执行操作，应用程序必须调用其拥有的对所请求的服务具有足够访问权限的功能。有了这一点，系统可以配置为彼此隔离的软件组件，也可以通过有选择地授予特定的通信能力，在组件之间实现授权的、受控的通信。这使得软件组件隔离具有高度的安全性，因为只有那些由功能拥有明确授权的操作才被允许。

一个权限空间是一个不可伪造的令牌，它引用特定的内核对象(如线程控制块TCB)，并携带控制可能调用哪些方法的访问权限。从概念上讲，权限存在于应用程序的权限空间中;这个空间中的地址指的是一个可能包含也可能不包含权限的槽位。应用程序可以引用一种权限（例如，请求内核服务，也就是使用持有该权限的槽的地址）。这意味着，seL4权限模型是一个隔离(或分区)权限系统的实例，其中的权限由内核管理。

权限空间被实现为内核管理权限节点(Cnode)的有向图。CNode是槽（Slot）组成的表，其中每个槽可能包含更多的CNode功能。权限空间中的一个权限地址是连接Cnode中的槽位索引，形成到目标槽位的路径;[第三章](#第三章)详细讨论了CNode对象。

权限可以在权限空间内复制和移动，也可以通过IPC发送。这允许创建具有特定访问权限的应用程序，将权限委托给另一个应用程序，并将应用程序权限传递给新创建(或选定)的内核服务。此外，可以创建带有原始功能权限子集的派生权限(不可以创建比原来权限集范围更大的权限)。新创建的权限可用于部分授权。

还可以撤销（revoke）权限（capability）以撤销授权（authority）。撤销（revoke）递归地删除从被撤销的原始权限派生出来的任何权限。权限在系统中的传播由基于授权的模型控制（ [EKE08, Boy09]不知道啥东西）。

### **2.2系统调用**

seL4内核为线程之间的通信提供了消息传递服务。这种机制也用于与内核提供的服务进行通信。有一种标准的消息格式，每条消息包含许多数据，可能还包含一些权限。这些消息的结构和编码将在[第四章](#第四章)中详细描述。

线程通过在其权限空间内调用（invoke）权限来发送消息。当以这种方式调用端点、通知或应答权限（权限有端点权限endpoint capability、通知权限notification capability、应答权限reply capability等）时，消息将通过内核传输到另一个线程。当调用内核对象的其他权限时，消息将以特定于内核对象类型的方式解释为方法调用。例如，使用正确格式的消息调用线程控制块(TCB)权限将暂停目标线程。

从根本上说，我们可以认为内核提供了三个系统调用:Send、Receive和Yield。但是，还有基本的Send和Receive调用的组合和变体。一个重要的变体是Call操作，它由一个标准的Send操作和一个等待应答的Receive操作组成。回复消息总是通过一个特殊的资源来传递，而不是使用标准的IPC机制;详情请参见下面的seL4_Call()。

在内核对象上调用除端点权限和通知权限之外的方法（权限？）是通过Send或Call来完成的，这取决于调用者是(Call)否 (Send)需要内核的响应。通过使用libsel4 API提供的函数，您可以保证始终使用更合适的函数。Yield系统调用不与任何内核对象关联，并且是唯一不调用权限的操作。在MCS配置中，Wait是Receive的一个变体，它不需要提供应答对象——在非MCS配置中，Wait是Receive的同义词，因为两个调用都没有提供应答对象（也就是说，MCS配置中Receive是要提供应答对象的，非MCS配置中的Receive是不需要提供的，而Wait不管什么情况都不需要提供应答对象）。

基本的系统调用如下:

seL4_Yield()是唯一不需要使用权限的系统调用。它没收了调用它的线程的时间片的剩余部分，并导致内核调度器的调用。如果没有与调用者具有相同优先级的其他可运行线程，调用线程将立即用一个新的时间片调度。在MCS配置中，这种行为取决于调度上下文的状态;详见6.1.6节。

seL4_Send()通过指定的权限传递消息。如果调用的权限是端点权限，并且没有接收方准备立即接收消息，则发送线程将阻塞，直到可以传递消息为止。接收对象不会返回错误代码或响应（官网上IPC部分说过这样能避免反向通道 back channel）。
seL4_Recv() (" receive ")用于线程通过端点或通知接收消息。如果没有发送方或通知处于挂起状态，则调用方将阻塞，直到可以传递消息或通知为止。此系统调用仅在端点Endpoint权限或通知Notification权限上才起作用，当尝试使用其他功能类型时将引发错误(参见6.2节)。在MCS配置中，Receive接受一个应答权限(应答对象的权限)作为参数。

其余的系统调用是seL4_Send()和seL4_Recv()的变体和组合，可以有效地适应系统编程中的常见用例。

seL4_NBSend()在端点上执行轮询发送。如果消息不能立即传递，也就是说，目标端点上没有等待接收者，则消息将被静默地丢弃。发送线程继续执行。与seL4_Send()一样，不会返回错误代码或响应。

seL4_NBRecv()被线程用来检查通知对象上挂起的信号或端点上挂起的消息，而不会阻塞。此系统调用仅对端点权限和通知权限起作用（类似普通Recv），当尝试使用其他功能类型时将引发错误(参见6.2节)。

seL4_Call()结合了seL4_Send()和seL4_Recv()，并有一些重要的区别。调用将阻塞发送线程，直到它的消息被传递并收到回复消息。当调用内核服务而不是端点的权限时，使用seL4_Call()允许内核通过应答消息返回错误代码或其他响应。当发送的消息通过端点传递到另一个线程时，内核执行与seL4_Send()相同的操作。接下来发生什么取决于内核配置。对于MCS配置，内核然后更新接收方提供的应答对象。应答对象是跟踪应答消息的容器，用于发送应答消息并唤醒调用者。在非MCS配置中，内核会在接收端TCB的一个专用插槽（Slot）中存储一个特殊的应答权限。此应答权限是发送应答消息并唤醒调用者的单一使用权限，这意味着一旦调用该应答消息，内核就会使其失效。对于这两个变体，在调用应答对象的权限之前，调用线程都会被阻塞。更多信息请参见4.2.4节。

seL4_Reply()用于响应seL4_Call()，方法是调用应答权限，这个应答权限是由seL4_Call()系统调用生成并存储在应答线程TCB的专用槽中的。它具有与使用seL4_Send()调用应答权限完全相同的行为，这在4.2.4节中有描述。

seL4_ReplyRecv()由seL4_Reply()和seL4_Recv()组合而成。它的存在主要是为了提高效率，也就是说，通常情况下，响应一个请求并等待下一个请求可以在单个内核系统调用中执行，而不是两个。从应答到接收阶段的转换也是原子性的。

seL4_Wait()类似于seL4_Recv();在非MCS配置上，它们实际上是同义的。在MCS配置中，当不需要应答时使用seL4_Wait()。与seL4_Recv()不同，seL4_Wait()不接受应答权限。

seL4_NBWait()(仅MCS)被线程用于通过端点或通知轮询消息。如果没有等待的发送方或通知，系统调用将立即返回。

seL4_NBSendWait()(仅MCS)将seL4_NBSend()和seL4_Wait()组合成一个原子系统调用。

seL4_NBSendRecv()(仅MCS)将seL4_NBSend()和seL4_Recv()组合成一个原子系统调用。


### **2.3内核对象**

本节简要概述内核实现的对象类型，应用程序可以调用这些对象的实例（也成为对象）。这些对象的接口构成内核本身的接口。内核服务的创建和使用是通过创建、操作和组合这些内核对象来实现的。

**CNodes**(见第三章)存储权限，赋予线程调用特定对象方法的权限。每个CNode都有固定数量的插槽（Slot），总是2的指数幂，这取决于CNode是在什么时候创建的。插槽可以是空的，也可以包含一个权限的。

**Thread Control Blocks**线程控制块(TCBs;(参见第6章)在seL4中表示一个执行的线程。线程是调度、阻塞、解除阻塞等执行的单元，这取决于应用程序与其他线程的交互。

**Scheduling contexts**(仅MCS)调度上下文(见第6章)在seL4中表示CPU时间。用户可以从非类型化（untyped）对象创建调度上下文，但是在创建时调度上下文是空的，不代表任何时间。最初，每个节点都有一个SchedControl权限，它允许使用参数填充调度上下文，这些参数需要和优先级控制线程（ priority control
thread）对CPU时间的访问结合。
**Endpoints**端点(参见第4章)促进线程之间的消息传递通信。IPC是同步的:试图在端点上发送或接收消息的线程会阻塞，直到消息能够被传递。这意味着，只有当发送方和接收方在端点汇合时，才会发生消息传递，并且内核可以使用单个副本传递消息(或者仅使用寄存器，不复制短的消息)。
**Reply objects**回复对象(仅MCS)(见第4章)跟踪调度上下文，并为一次性回复权限提供一个容器。它们由seL4_Recv()提供。
**Notification Objects**通知对象(见第5章)提供了一个简单的信令机制。Notification是一个字大小的标志数组，每个标志的行为都类似于二进制信号量。其上操作有：seL4_Signal（）在单个操作中发送全体标志集的子集；seL4_Poll（）轮询检查任何标志；seL4_Wait（）在收到信号前阻塞。通知权限可以是仅信号（signal-only）或仅等待（ wait-only）。
**Virtual Address Space Objects**虚拟地址空间对象(见第七章)，用于为一个或多个线程构造一个虚拟地址空间(又称VSpace)。这些对象在很大程度上直接对应于硬件，因此是依赖于体系结构的。内核还包括ASID Pool和ASID Control对象，用于跟踪地址空间的状态。
**Interrupt Objects**中断对象(见第8章)使应用程序能够接收并确认来自硬件设备的中断。最初，IRQControl有一个权限，它允许创建IRQHandler权限。一个IRQHandler权限允许管理与特定设备关联的特定中断源。它被委派给设备驱动程序以访问中断源。
IRQHandler允许线程等待并确认单个中断。
**Untyped Memory**无类型内存(参见2.4节)是seL4内核中内存分配的基础。无类型内存权限有一个单一的方法，它允许创建新的内核对象。如果方法成功，调用线程将获得对新创建对象的权限的访问权。此外，无类型内存对象可以被分成一组较小的无类型内存对象，允许委托部分(或全部)系统内存。我们将在下面的章节中讨论内存管理。

### **2.4内核内存分配**

seL4微内核不动态地为内核对象分配内存。相反，对象必须通过Untyped memory权限从应用程序控制的内存区域显式创建。为了创建新对象，应用程序必须具有对内存的显式权限(通过这些Untyped memory权限获得)，而所有对象在创建后都将消耗固定数量的内存。这些机制可用于精确控制应用程序可用物理内存的特定数量，包括能够在应用程序或设备之间强制物理内存访问的隔离。除了那些由硬件（对虚拟ASID的处理强加了固定数量的地址空间。这个限制将在seL4的未来版本中消除）决定的限制外，内核中没有任何的资源限制，因此可以避免许多通过资源耗尽而导致的Dos攻击。













## **她她她**