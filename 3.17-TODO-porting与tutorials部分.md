# porting

seL4网站：[Porting seL4 to a new platform ](https://docs.sel4.systems/projects/sel4/porting)。

FAQ：[Frequently Asked Questions on seL4 ](https://docs.sel4.systems/projects/sel4/frequently-asked-questions.html)。

[Tutorials | seL4 docs](https://docs.sel4.systems/Tutorials/)。感觉这里面的seL4 mechanisms tutorials有点用。

libsel4 API：[API Reference | seL4 docs](https://docs.sel4.systems/projects/sel4/api-doc.html)。

知乎博客：https://zhuanlan.zhihu.com/p/466424606。

csdn博客：[sel4源码解析（一） - sel4内核对象_Mr0cheng的专栏-CSDN博客_sel4内核](https://blog.csdn.net/Mr0cheng/article/details/104338058)。

## Porting seL4 to a new platform

根据网页：[Porting seL4 to a new platform ](https://docs.sel4.systems/projects/sel4/porting)。

tree命令，将当前目录打印到某文件。

```
tree [-L n]> fileTree.txt #-L n为限制层级，e.g.-L 2，重定向输出至fileTree.txt
```

根目录：

```
.
├── build
├── CAVEATS-generic.md
├── CAVEATS-ia32.md
├── CHANGES
├── CMakeLists.txt
├── CODE_OF_CONDUCT.md
├── config.cmake
├── configs
├── CONTRIBUTING.md
├── CONTRIBUTORS.md
├── FindseL4.cmake
├── gcc.cmake
├── gdb-macros
├── include
├── libsel4 #libsel4/sel4_plat_include/<platform>/sel4/plat/api/constants.h
├── LICENSE.md
├── LICENSES
├── llvm.cmake
├── manual
├── README.md
├── src
├── tools
├── treefile.txt
└── VERSION
```

* DTS修改：在tools/dts/update-dts.sh
* Hardware generation script修改：在tools/hardware.yml
  * Drivers：/src/drivers/
  * Drivers：/include/drivers/
* kernel：在libsel4/sel4_plat_include/\<platform>/sel4/plat/api/constants.h添加支持

* CMake-Build System：在kernel/src/plat/\<platform>/config.cmake，以及tools/seL4/cmake-tool/helpers/application_settings.cmake，还有tools/seL4/elfloader-tool/CMakeLists.txt
* elf-loader：在tools/seL4/elfloader-tool/src/plat/\<platform>/sys_fputc.c，以及tools/seL4/elfloader-tool/include/plat/\<platform>/platform.h
* seL4test：在sel4test/projects/util_libs/libplatsupport/plat_include/\<platform>/platsupport/plat下添加头文件支持，在sel4test/projects/util_libs/libplatsupport/src/plat/\<platform>/下添加相应源文件。

# tutorials部分

参考网址：[Tutorials | seL4 docs](https://docs.sel4.systems/Tutorials/)。

先建立文件夹：

```
mkdir sel4-tutorials-manifest
cd sel4-tutorials-manifest
repo init -u https://github.com/seL4/sel4-tutorials-manifest
repo sync
```

在文件夹下，输入如下命令，查看相应的内容，选择参数，自动生成文件。

```
./init -h
```

例如：

```
./init --tut hello-world # 自动生成hello-world，hello-world_build
cd hello-world
ninja
./simulate
```

vscode跳转到上次位置：`shift+alt+-`

## helloworld

```
./simulate --extra-qemu-args="-s -S"
```

好像不能直接读入两个符号表。启动gdb 读入kernel的符号表：

```
gdb kernel/kernel.elf
target remote:1234
```

获取程序入口信息，设置断点

```
info files
```

![image-20220310163019083](images/tmp.assets/image-20220310163019083.png)

设置断点：

```
b *0x1002ea
```

另外，保存断点：

```
save breakpoint ${BPfilename}
```

下次调试文件时，在指定文件的同时，指定断点文件

```
gdb ${filename} -X ${BPfilename}
```

汇编好像用的AT&T语法。[汇编中 $ 和 % 符号的作用-andyhzw-ChinaUnix博客](http://blog.chinaunix.net/uid-28458801-id-3555479.html)。

AT&T语法中，$表示立即数，%表示寄存器。mov $4, %eax，是把4送入eax。



## capability

Capabilities：类似于句柄？

CNodes：类似于capabilities的数组？

CSlots：类似于CNodes中每个元素指针？

CSpace：属于一个线程的capability地址范围。根任务总是有一个指向CNode的root Capability，可以利用root capability查找对应CSlot中指向的capability。



## Untyped

### Background

启动阶段创建对象的cap，以及其他物理资源，在启动时会传递给root task

除了用来创建根任务的cap，指向其他可得物理资源的cap会传递给root task，这些cap指向的是untyped memory。无类型cap是指向无类型内存的cap。无类型cap可以重新指向内核其他对象，或者更小的无类型内存。

device：boolean类型的属性，指示内存是否可被内核写，这片内存可能不由ram设备支持而是其他设备支持的内存，或者是ram内无法由内核寻址的空间。device为true的无类型cap只能重新指向帧对象（可以被映射到虚拟内存的物理内存帧），但是不能被内核写。

### Initial state

seL4_BootInfo描述所有无类型cap，提供给root task，包括大小，device untyped？以及物理地址。

### Retyping

 seL4_Untyped_Retype，可以用来创建新的cap。创建出来的新cap提供对原cap内存子区域的访问，要么是更小区域无类型cap，要么是指向特定类型的新对象cap。新cap是原cap的children。

无类型cap以贪心的增量方式retype，这有助于内存的高效利用。每个无类型cap维护一个watermark，watermark包含retype前的地址和retype开始时的地址。在retype时候，watermark首先是对象的对其地址，最后是末地址。创建对象要按照占据内存从大到小排序创建。

![image-20220314224747372](images/3.11-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/image-20220314224747372.png)

#### Types

libsel4下，可以找到对象的类型的描述。有些是架构特有的，其他的是各个架构都有的。然后讲了上面函数的内容。

#### Size

该函数的size参数的一些情况：

* 多数对象都是固定的size，内核忽略改参数。
* seL4_UntypedObject 和seL4_SchedContextObject允许可变size，由参数指定。2的size次方。
* seL4_CapTableObject 也是可变size，改参数是slot数量。

`For retype, it is enough to remember that the parameter size_bits means the object will measure 2size_bits bytes, and for seL4_CapTableObject that you are requesting 2size_bits slots (you can compute the size in bytes by taking 2size_bits + seL4_SlotBits`

#### Root, node_index & node_depth

node_depth设为0，意味着invocation方式寻址。index忽略。

node_depth不设为0，直接寻址。当前线程的scpace root作为root，index指向CNode，depth是index指向CNode的大小。为多层cspace设计的。

#### Node_offset

CNode中选的CSlot偏移

#### Num_caps

该函数可以创建多个cap和object。

注意：untyped必须足够大来装入所有需要的内存。要有连串的空闲CSlot放cap。

### 一些问题

 tut代码中， seL4_Untyped_Retype(child_untyped, seL4_TCBObject, 0, seL4_CapInitThreadCNode, 0, 0, child_tcb, 1);

为啥是CapInitThreadCNode？初始化时候，还没有创建其他线程。

## Virtual memory

[地址映射_zyn19950120的博客-CSDN博客_地址映射](https://blog.csdn.net/zyn19950120/article/details/77647761?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=2)。

[C语言字节对齐详解_OopspoO的博客-CSDN博客_字节对齐](https://blog.csdn.net/cclethe/article/details/79659590)。

### Background

seL4不提供虚拟内存管理，除了用来操作硬件分页结构的内核原语。**用户提供中间分页结构、映射和取消映射页面的服务。**

用户可自由定义地址空间布局，遵守限制：`On most 32-bit platforms, this is 0xe0000000 and above`，kernelBase变量。

### Paging structures

VSpace：根任务初始化时候的虚拟存储对象。由seL4_CapInitThreadVSpace指向该结构。各种arch下的object type不同。它是top-level的。

![image-20220316095803612](images/3.15-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/image-20220316095803612.png)

除了top-level的，中间硬件虚拟存储对象也被用来映射页。

![image-20220316100248653](images/3.15-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/image-20220316100248653.png)

可以通过调用来确定是否映射。`seL4_X86_PDPT_Map(pdpt, seL4_CapInitThreadVSpace, TEST_VADDR, seL4_X86_Default_VMAttributes)`该函数的三个参数：VSpace，vaddr，vattributes，第一个参数是被映射的对象。vattributes是映射时高速缓存的属性，与架构相关，libsel4中可以看到。

![image-20220316102906890](images/3.15-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/image-20220316102906890.png)

如果虚拟地址参数与映射对象大小不是对齐的，seL4将会mask out任何未使用的位。例如4KB的页被映射到0xDEADBEEF，最终会被映射到0xDEADB000。

### Pages

对于特定的虚拟地址range，一旦所有的中间映射结构被设计好，通过调用帧的cap，该帧就可以被映射进去了。代码片段展示了将frame映射到test_vaddr。

![image-20220316103522679](images/3.15-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/image-20220316103522679.png)

libsel4中的函数seL4_MappingFailedLookupLevel决定哪一级映射结构缺失。多级映射，每一级要有一个cap，每个cap只能追踪一级映射。上面函数中还有个rights参数，它决定着映射权限。

#### Types and sizes

页类型和数量与架构有关。x86和ARM架构上，各个size的页类型不同。在RISCV上，页类型相同但大小不尽相同。通过改变配置来改变页大小。

### 疑问

mapping里涉及的几个参数是怎么理解？
pdpt是“pd的目录”的cap吗，对应seL4_X86_PDPT_Map
pd是pd的cap，对应seL4_X86_PageDirectory_Map
pt是pt的cap，对应seL4_X86_PageTable_Map
具体页cap，对应seL4_X86_Page_Map

## Threads

[sel4源码解析（六） - 进程_Mr0cheng的博客-CSDN博客](https://blog.csdn.net/Mr0cheng/article/details/104338064)。

### Background

#### TCB

sel4用线程来表示执行上下文并管理处理器时间。sel4中的线程由线程控制块TCB对象实现，每个线程有个线程控制块。

TCB包含如下信息：

* 优先级别以及最大控制优先级
* 寄存器状态和浮点上下文
* cspace 的cap
* vsapce 的cap
* 端点cap，用于发送错误消息
* reply cap，回复cap？

#### Scheduling model

sel4调度器调度thread到某个处理器上运行，调度算法是基于优先级的round-robin调度。调度器会选择可以运行的threads，基于这样的条件：在任何IPC操作上不会被阻止并可以恢复。

##### Priorities

0-255的优先级，调度器选择最高的优先级。libsel4中有编码。kernel/libsel4/include/sel4/constants.h。

TCB还有个MCP属性。设置TCB优先级的时候，必须准确提供tcb的cap。优先级由tcb的mcp检查，如果被设置的优先级过高，就设置失败。根任务最初的priority和MCP都设为seL4_MaxPrio。

##### Round robin时间片轮转

多个tcb可以运行，优先级相同时，它们以先进先出的round-robin方式被调度。内核时间按照固定时间量tick的数量来计算。tcb有个时间片字段，表示被抢占前可以执行的tick数。内核时间驱动，被配置为出发周期性中断的方式，中断会标记每个tick。当时间片耗尽时，该算法起作用。thread通过seL4_Yield放弃当前的时间片占用。

##### Domain scheduling

为了保证机密性，sel4提供了顶级分层调度程序，它能够提供调度分区(即域)的静态调度，周期性调度。在编译时，域将被静态配置为不可抢占式的周期性调度，这会导致完全确定性的调度。

线程可以被分配进域，线程只有在域活跃时才会被调度。跨域的IPC需要等待域切换完成，域间的seL4_Yield不被允许。假如调度了域，但是域内没有运行thread，域内特定的空闲线程将运行直到发生域切换。

通过seL4_DomainSet cap，将thread加入domain。

#### Thread Attributes

sel4线程在tcb的invocation中被配置。

### Exercise

#### CapDL Loader

之前的tutorials都在根任务中，起始scpace布局是由sel4 boot 程序设置的。这个教程使用capDL loader，它是分配静态配置对象和cap的root task。

capDL loader能够解析对系统和相关elf二进制文件的静态描述，从而分配静态配置对象和cap。它主要用于camkes项目也用于教程减少冗余代码。你创建的程序最终会有它自己的cspace和vspace，它们与root task是分开的，这意味着seL4_CapInitThreadVSpace这样的cslot在capDL loader加载的程序中是无意义的。

#### Configure a TCB

debug syscalls在libsel4中可以找到。seL4_DebugDumpScheduler()可以转储调度器的状态。

问题：

![QQ图片20220316222024](images/3.15-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/QQ%E5%9B%BE%E7%89%8720220316222024.png)

看注释里说这是current thread的root_cnode和root_vspace。不是创建了一个新的tcb么，不用新指定root_cnode吗？还是说，这是子线程关系，所以用的父线程一样的root_cnode?--应该是

![QQ图片20220316222031](images/3.15-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/QQ%E5%9B%BE%E7%89%8720220316222031.png)

另外，内核启动以后，未创建新线程前，不是只有一个线程么，这里有rootserver和idle可以理解，为啥还有tcb_threads线程？

试了下helloworld，确实只有2个：

![image-20220316235054280](images/3.15-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/image-20220316235054280.png)

即从helloworld里打印是没有的，搜了一下，感觉是某处创建了这个线程。

#### Change priority via seL4_TCB_SetPriority

新建线程的priority为0，但loader创建的线程优先级是254，改变线程优先级才能被轮询算法调度。改变其他线程优先级的线程必须有权限。

#### set thread's register set.

TCB还需设置初始寄存器才能运行，`set the program counter and stack pointer to valid values`。`libsel4utils`包含一些设置寄存器的函数，它是与平台无关的方式设置的。假设栈在所有平台上都是向下增长的。

[X86-64寄存器和栈帧_Rain2536的博客-CSDN博客_rsp寄存器](https://blog.csdn.net/dayancn/article/details/51328959?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_paycolumn_v3&spm=1001.2101.3001.4242.1&utm_relevant_index=3)。

![QQ图片20220317104504](images/3.16-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/QQ%E5%9B%BE%E7%89%8720220317104504.jpg)

#### Start the thread

seL4_TCB_Resume即可

#### Passing arguments

目前参数全0，用函数sel4utils_arch_init_local_context可以传递参数。

#### Resolving a fault 处理错误

现在创建的thread还没有fault handler。本例子中，尝试发送错误信息，是个vm错误。新线程尝试访问0x2，它是非法未映射的地址。显示了PC值，出故障0x401e66。

错误状态寄存器也是输出，可以使用架构手册查看。另外，内核打印了堆栈转储信息。转储信息内容可以配置。

在加载的elf文件上，用objdump检查导致故障的指令，elf文件位于`threads_build/threads`,

![img](images/3.16-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/$YT_T_A02CL%5B%5BCYP%7BGK%5B0Q6.png)

此处可看出将arg2内的值取出放入eax。

最后正确传递参数，新线程运行起来了，输出了42

![image-20220317153723305](images/3.16-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/image-20220317153723305.png)

## IPC

### Background

IPC是微内核进程间，同步传输少量数据和cap的机制。在sel4中，IPC的实施依赖于endpoints内核对象，该对象是通用通讯端口。endpoint上的函数调用被用来发送和接收IPC消息。

endpoint由等待发送或接收消息的线程队列组成。如果有n个线程在endpoint队列上等待消息，此时有n个线程发送消息，这n个等待线程就会收到消息并wake up，如果n+1个线程发送消息，多一个进入等待队列。

#### system calls

seL4_Send发送，阻塞，直到有线程接收。

seL4_NBSend发送，只有接收线程阻塞等待接收，才能成功发送，不返回是否发送成功的消息。

seL4_Recv 发送消息。

seL4_NBRecv 发送消息，应该是只有线程阻塞发送，才能接收成功。

seL4_Call 是系统调用，结合了seL4_Send和seL4_Recv，但有个区别：使用该函数的发送线程会被回复cap（一次性cap）阻塞，而不是endpoint自己阻塞，直到发送线程成功发送并接收到回复。在客户端服务器模式下，客户使用seL4_Call 发出请求，服务器可以向正确的客户返回明确的回复。

reply cap存储在接收线程TCB的内部。seL4_Reply系统调用这个cap，它将向客户发送IPC并唤醒它。seL4_ReplyRecv也是这样，只不过在组合系统调用中，它回复消息并在endpoint阻塞。

TCB仅有单独空间存放reply cap，如果服务器需要回复多个请求，[`seL4_CNode_SaveCaller`](https://docs.sel4.systems/ApiDoc.html#save-caller)可以用来存储reply cap到接收者cspace的空槽中。

#### IPC Buffer

每个线程有个缓冲区，包含IPC消息（由数据和cap组成），发送者指明消息长度，内核复制该数值给接收者。

#### Data transfer

IPC buffer有一些消息寄存器用来传递数据，每个寄存器是word 大小，最大消息size在libsel4的seL4_MsgMaxLength中。

消息可以用seL4_SetMR装入IPC缓冲区，用get函数提取出来。短消息被送入寄存器不需要复制操作。seL4_FastMessageRegisters常数中提到了能够放入寄存器的字的数量。

需要使用的消息寄存器数量，必须在length字段设置，该字段在seL4_MessageInfo_t结构体中。

#### Cap transfer

除了消息，IPC在每次进程通讯时，还可以发送cap。即 cap transfer。传递的cap数量是extraCaps，在seL4_MessageInfo_t结构体中。

接收者收到的cap权限与接收者对endpoint的权限相同，这样就可以通过各种权限的endpoint来得到各种权限的cap了？？？？？？？？

#### Capability unwrapping？？？？

seL4_IPCBuffer结构体中，第n个如果是unwrapped，那么就在接收方相应的槽中的位置放入badge，内核设置tag中的第n bit位标记为unwrapped，cap本身不会被发送。

非unwrapped则要复制发送。

sel4允许cap的接收者（同时也是这个cap的发送者）自定义cap value而不是用新名称，这种方式叫unwrapped。如果传送的cap是endpoint cap，接收方是这个endpoint cap的创建者。

![image-20220317213259231](images/3.16-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/image-20220317213259231.png)

[Genode - Genode on seL4 - IPC and virtual memory](https://genode.org/documentation/articles/sel4_part_2)。

#### seL4_MessageInfo_t 

seL4_MessageInfo_t 包含：

* length 
* extraCaps 
* capsUnwrapped 
* label

![image-20220317215617001](images/3.16-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/image-20220317215617001.png)

#### Badges

发送方可能发送endpoint的badge。endpoint可以通过seL4_CNode_Mint或seL4_CNode_Mutate加上标记，一旦被标记，这个badge将被传递给用该endpoint传递消息的任何接收方。

sel4_Recv不理解。

#### Fastpath

内核中经过高度优化的路径，满足下列条件才能使用：

- `seL4_Call` or `seL4_ReplyRecv` 的调用
- 数据正好能装入 `seL4_FastMessageRegisters` 寄存器.
- 进程必须有合法的地址空间.
- 不能传送任何cap.
- 不存在比IPC非阻塞线程的优先级更高的线程可以运行























