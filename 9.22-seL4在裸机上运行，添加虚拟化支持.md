# ejtag+gdb

ejtag连网线，ip a 命令可以查看ip(10.90.50.195/24)

ejtag启动，记住ip，source之后，启动被调试机，再从ejtag启动gdbserver。

在调试机上启动gdb，输入

```
loongarch64-unknown-linux-gnu-gdb build_3A5000/images/sel4test-driver-image-loongarch-3A5000
target remote 10.90.50.?:50010
b *0x9000000002000000
b 
cont #grub那边boot即可停到elfloader入口0x9000000002000000，然后加符号表，提前加有问题

add-symbol-file build_3A5000/elfloader/elfloader
add-symbol-file build_3A5000/kernel/kernel.elf
add-symbol-file build_3A5000/apps/sel4test-driver/sel4test-driver
add-symbol-file build_3A5000/images/sel4test-driver-image-loongarch-3A5000
```



# seL4在裸机上跑

制作iso并烧录

```
mkisofs -r -o xxx.iso xxx
dd if=xxx of=/dev/sda#诸如之类的,lsblk查看外设磁盘
sync
```

串口输出：

```
sudo picocom -b 115200 /dev/ttyUSB0
```

grub2命令：

```
linux (hd0,gpt2)/sel4
root=/dev/ram0 LABEL=boot console=ttyS0,115200
boot
```

尝试改elf文件的链接地址，因为uefi bios做了映射窗口

```
0x9000000002000000
```

查看新插入的USB设备：

```
ls -l /dev/ttyUSB0
```

minicom使用方法：

```
minicom -s# 设置并保存也可进入
sudo minicom -D /dev/ttyUSB0#用ls -l /dev/tty+tab补全查看
```

ejtag使用方法：

连接ejtag的usb，minicom进入/tmp/ejtag-debug，运行./la_dbg_tool_gpio。

```
source configs/config.ls3a5000#然后再开机
#必须使用硬件断点调试 hb 0x900000000e000000[entry]

#退出：
exit #先exit退出ejta
#关掉ejtag电源
```



ejtag 的usb插入无法识别问题，删掉这个东西重新插入即可

```
sudo apt-get purge brltty
```



## 修改

装载入口点地址，经过bios映射窗口，改为

```
0x900000000200000
```

不增加0x0000000...011的窗口

dts的uart地址改为：

```
```

删去kernel的bss段清零代码。因为清零过程中会打印乱码，riscv没有bss清零操作，我用ejtag看了那个bss段，初始值也确实是0。删去后不再打印乱码。

内核的uart相关页表项的权限加了宏，如果是debug build等级改成plv3（让用户可以在debug模式下使用内核的uart），否则改为0，rplv=0，页表项改成nocache。qemu里这部分没有检查？

之前说没有修改musl，可能是因为debug build模式，很多地方直接使用内核的内容，qemu没有检查出来。

内核态uart使用uncache并且plv0，用户通过系统调用使用printf。



进入test，尝试分配对象，从最大的size尝试，不断减小，找到合适的size，这个过程允许报错。





用户空间的putchar，需要初始化设备。

```
__arch_putchar
```

* 关于用户的uart。

projects/sel4test/apps/sel4test-driver/src/main.c的main调用了platsupport_serial_setup_simple。

projects/seL4_libs/libsel4platsupport/src/common.c的platsupport_serial_setup_simple调用了platsupport_serial_setup_io_ops。但是我们也开了debug_build，所以可以使用内核的打印函数？？？？？

projects/seL4_libs/libsel4platsupport/src/common.c的platsupport_serial_setup_io_ops调用__plat_serial_init

projects/seL4_libs/libsel4platsupport/src/serial.c调用初始化设备函数__plat_serial_init。

projects/util_libs/libplatsupport/src/plat/3A5000/serial.c初始化设备，给uart建立页表映射，getchar，putchar

* 关于用户使用内核debug版本的uart

?的__stdio_write调用init_syscall_table。

projects/seL4_libs/libsel4muslcsys/src/vsyscall.c的init_syscall_table调用了sys_writev。

projects/seL4_libs/libsel4muslcsys/src/sys_io.c的sys_writev调用了stdio_write

projects/seL4_libs/libsel4muslcsys/src/sys_io.c的stdio_write指向sys_platform_write

projects/seL4_libs/libsel4muslcsys/src/sys_io.c的sys_platform_write调用了__arch_write。

projects/seL4_libs/libsel4platsupport/src/common.c的\_\_arch_write调用了\__arch_putchar

projects/seL4_libs/libsel4platsupport/src/common.c的\_\_arch_putchar（不是weak函数）调用了__serial_setup。

__serial_setup里NOT_INITIALIZED状态。



* 找错误----错误打印消息路径

projects/sel4test/apps/sel4test-driver/src/main.c的printf("=\=\=\=\=====\n");之后

_zf_log_write_d进入g_output_cb，进入output_callback，进入\_\_fwritex，write=__stdio_write。

进入__stdio_write的cnt = syscall(SYS_writev, f->fd, iov, iovcnt)，

进入projects/seL4_libs/libsel4muslcsys/src/vsyscall.c的long sel4_vsyscall(long sysnum, ...)。

syscall指向sys_writev，

sys_writev里，stdio_write是sys_platform_write，调用__arch_write。最终调用\_\_arch_putchar。

__plat_putchar调用ps_cdev_putchar，console？

projects/seL4_libs/libsel4platsupport/src/serial.c有

```
static struct ps_chardevice console_device = {
    .write = &debug_write
};
static struct ps_chardevice *console = &console_device;
```

进入ps_cdev_putchar，write指向debug_write。调用seL4_DebugPutChar.

进入loongarch_sys_send_recv

进入slowpath，调用号-9，进入handleUnknownSyscall

进入kernel_putchar，进kernel_putDebugChar，进uart_console_putchar，进uart_drv_putchar。



* 用户态printf的路径

debug_print_bootinfo的printf

printf进入0x120065820的projects/musllibc/src/stdio/puts.c的puts

进入projects/musllibc/src/stdio/fputs.c的fputs

进入projects/musllibc/src/stdio/fwrite.c的fwrite

进入projects/musllibc/src/stdio/fwrite.c的__fwritex

__overflow的write指向\_\_stdio_write后面相同



* projects/sel4test/apps/sel4test-driver/src/main.c的426行宏定义相关的内容



创建用户线程空间的东西。

create_it_address_space

create_frames_of_region



卡死在projects/seL4_libs/libsel4allocman/src/utspace/split.c的320行seL4_Untyped_Retype上，需要ejtag调试一下看具体卡在哪。

projects/seL4_libs/libsel4allocman/src/allocman.c的287行有问题，进入_utspace_split_alloc

先停到main_continued 0x120003adc

再停到_utspace_split_alloc 0x12001c460-

la 再停到seL4_Untyped_Retype 0x12001c860

12001b194进入CallWithMRs

卡在12001c810：ld.d \$t0, $fp, -104(0xf98)。t0的地址是0x1202e3650，该地址在qemu可以查看，在真机上不能查看？该地址是allocator_mem_pool相关内容。



Thread 1 received signal sigint interrupt





尝试将所有的表项改为uncache，不行，一进用户态就报错



内核态uart使用uncache并且plv0，用户通过系统调用使用printf。





进入了fastpath

进入decodeInvocation

进入decodeUntypedInvocation

进入invokeUntyped_Retype

卡在invokeUntyped_Retype的292行里

进入resetUntypedCap



regionBase=0xffff8001 7c00 0000

offset=0x1100200，变成0x1100300

regionBase+offset=0xFFFF 8001 7D10 0200--> 0xFFFF 8001 7D10 0300，物理地址=0x1 7D10 0300，映射窗口=0x9000 0001 7D10 0300，读出数据为0。测试代码地址在0xffff810010011408

chunk=8

发现检查完17826560就卡到17826304

卡在

![image-20221009201714206](/home/lqt/projects/seL4projects/seL4-oscompProblemSolutions/images/9.22-seL4在裸机上运行，添加虚拟化支持.assets/image-20221009201714206.png)

如果test 0x900000017d1003c0，则可以通过，卡在900000017d100200

如果test 0x900000017d100200，则可以通过，卡在900000017d1003c0



如果同时test，卡在offset=0x1200200，也就是9000 0000 936a 0200





# head.S?

地址在0xffff810010000030

![image-20221010143909679](/home/lqt/projects/seL4projects/seL4-oscompProblemSolutions/images/9.22-seL4在裸机上运行，添加虚拟化支持.assets/image-20221010143909679.png)

t0每次+8，直到等于t1



![image-20221010144825477](/home/lqt/projects/seL4projects/seL4-oscompProblemSolutions/images/9.22-seL4在裸机上运行，添加虚拟化支持.assets/image-20221010144825477.png)



修改出大页，执行head.S第一条指令，然后跳转到了一片未知的代码，像是bios里的例外处理？



64G：进入head.S，前两条指令可以正常tlbrefill，往后走几条指令到0xffff810000000018，再si，就会跳转到0x90000000fe3d58f0的地址，该地址看起来是通过窗口访问的，物理地址应该有效，但是我们的代码里没有这个地址，反汇编该地址的代码，可以看到类似于trap处理。有可能是bios里设置了一个trap入口？用set查看trap入口是0x9000000000000000。为了检查是不是触发了例外，我在elfloader里设置了trap入口，发现head.S里0xffff810000000018位置si还是会跳到0x90000000fe3d58f0的地址，不知道这个地址的意义。



![image-20221011152434137](/home/lqt/projects/seL4projects/seL4-oscompProblemSolutions/images/9.22-seL4在裸机上运行，添加虚拟化支持.assets/image-20221011152434137.png)

32M：进入head.S，清空bss段前后紧邻的汇编指令都没产生乱码。清理bss段过程中，打断点在0x90000000fe3d58f0地址，清空bss段也不会停下。也没有进入elfloader的trap入口。

意外发现：如果在grub中boot内核之前就打断点0x90000000fe3d58f0，会多次进入断点位置，打印出XhcClearBiosOwnership的代码。在ELF-loader started才是elfloader打印的信息。

![image-20221011153300884](/home/lqt/projects/seL4projects/seL4-oscompProblemSolutions/images/9.22-seL4在裸机上运行，添加虚拟化支持.assets/image-20221011153300884.png)



ffff810000004da0是memzero清零核心指令前的一条。然后si 370，之后清零是可以的，在打印时候，跳转到ffff810000004370卡死。

ffff810000004d6c停不下来

![image-20221014154641227](/home/lqt/projects/seL4projects/seL4-oscompProblemSolutions/images/9.22-seL4在裸机上运行，添加虚拟化支持.assets/image-20221014154641227.png)

其他位置打同样断点，si，可以看到写出了字符。



删掉自己写的printf，还会卡在其他printf的st.b







# 64G或32M大页发现tlb的问题

## 问题一：进入内核的虚拟地址0xffff 8100 9000 0000，触发tlb refill，tlb refill代码，仅64G

 handle_tlb_refill:

![img](file:////tmp/wps-lqt/ksohtml/wps8uKF6N.jpg) 

其中红色框仅为debug用，非红色框是refill代码。

第一次执行lddir(0x9000 0000 0200 800c处指令)，t0值是0x11d3

![img](file:////tmp/wps-lqt/ksohtml/wpsib6vub.jpg) 

第二次执行lddir(0x9000 0000 0200 8010处指令)后，t0值是0x31d3。

![img](file:////tmp/wps-lqt/ksohtml/wpsU3rdsp.jpg) 

按照手册，页表项bit6是Huge位，第一次执行lddir指令后t0里已经是大页页表项，bit6=1，再执行lddir，t0的值不应该改变，但变成了0x31d3。

![img](file:////tmp/wps-lqt/ksohtml/wpsexqShx.jpg) 

真实机器上页表项格式是否和手册一致？



## 问题二 tlbrefill过程中，我添加了debug代码读tlbrehi寄存器到t1中，发现ldpte改变了tlbrehi的ps域。问题在红框代码处

### 64G

![img](file:////tmp/wps-lqt/ksohtml/wpsvgzWQ6.jpg) 

第一条ldpte执行之前(0x9000 0000 0200 8024)，读tlbrehi到t1中，是正确的值(0xffff 8100 9000 0024)。

![img](file:////tmp/wps-lqt/ksohtml/wpscqVSAs.jpg) 



第一条ldpte执行之后，读tlbrehi到t1中，ps域不再正确，从24变成了3f。如果折半，变成23？

![img](file:////tmp/wps-lqt/ksohtml/wps1kb9Xd.jpg)



### 32M真实机器

第一条ldpte之前，t1里是正常19，32M页

![image-20221013161248769](/home/lqt/projects/seL4projects/seL4-oscompProblemSolutions/images/9.22-seL4在裸机上运行，添加虚拟化支持.assets/image-20221013161248769.png)

之后，变成18，**18是否因为折半成16MB页？**

![image-20221013161333452](/home/lqt/projects/seL4projects/seL4-oscompProblemSolutions/images/9.22-seL4在裸机上运行，添加虚拟化支持.assets/image-20221013161333452.png)

### 32M qemu

和真机一样，ps域变化了。

![image-20221013161655750](/home/lqt/projects/seL4projects/seL4-oscompProblemSolutions/images/9.22-seL4在裸机上运行，添加虚拟化支持.assets/image-20221013161655750.png)







## 问题三

### 64G页

读出tlbrelo0,tlbrelo1，其中tlbrelo1有问题。

![img](file:////tmp/wps-lqt/ksohtml/wpsYKMews.jpg) 

 0x9000 0000 0200 8038处指令，读出tlbrelo0到t1中，是正常的0x53。

0x9000 0000 0200 803c处指令，读出tlbrelo1到t1中，最高位变成了1，该位对应RPLV，但是我们设置页表的RPLV为0。

![img](file:////tmp/wps-lqt/ksohtml/wpsHUowHT.jpg)



### 32M 页--真机

读出正常

![image-20221013162859863](/home/lqt/projects/seL4projects/seL4-oscompProblemSolutions/images/9.22-seL4在裸机上运行，添加虚拟化支持.assets/image-20221013162859863.png)



### 32M页--qemu

按照手册，bit[11:7]位读出来应该是0

![image-20221013162956656](/home/lqt/projects/seL4projects/seL4-oscompProblemSolutions/images/9.22-seL4在裸机上运行，添加虚拟化支持.assets/image-20221013162956656.png)



















