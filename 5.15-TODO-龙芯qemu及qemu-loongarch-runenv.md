# 安装龙芯的qemu

[qemu linux 命令 在线中文手册 (51yip.com)](http://linux.51yip.com/search/qemu)。

参考网址：

* [qemu/target/loongarch at tcg-dev · yangxiaojuan-loongson/qemu (github.com)](https://github.com/yangxiaojuan-loongson/qemu/tree/tcg-dev/target/loongarch)。
  * 装qemu时：需要下载他给的tcg-dev版本，或者git clone仓库再切换分支，注意其他分支是没有loongarch架构的。用户态，安装，然后暂时可以运行。系统态，从他给的binary仓库中好像有问题，老师在解决。
* https://github.com/sunhaiyong1978/CLFS-for-LoongArch/blob/main/Qemu_For_LoongArch64-Simple.md。
  * 这里面只有用户态。然后挺复杂？

ftp://182.92.153.183/uploads/qemu/clfs.img.xz，下载解压后，参考ftp://182.92.153.183/uploads/qemu/run-clfs.sh启动模拟器，可以进行系统，root密码为loongson。目前还有个小问题，systemd-resolved启动报错，不过重试几次后系统会放弃不影响启动。



这个系统是https://github.com/sunhaiyong1978/CLFS-for-LoongArch/，龙芯孙海勇做的从头构建linux的系统，他还写了一本手把手教clfs的书，有兴趣也可以去看看

Loongarch的操作系统开源的有loongnix（loongnix.cn），阿里的龙蜥和华为欧拉社区也在加入支持；商业的有麒麟和统信等。不过目前有个困难：loongarch的工具链ABI接口还在变化，和现有商业的不完全一致，目前最新的社区linux内核、工具链和bios并不兼容已有的loongnix和商业系统，可能会带来一些额外的麻烦。我这几天组织相关人员把模拟器上的一整套系统从源代码到二进制重新整理一遍，写个更系统些的文档供大家参考



上午那个clfs个头太大，刚刚基于busybox做了一个ramdisk，常见的命令都有才1M多，已经上传到ftp server 182.92.153.183的uploads/qemu/initrd.img, 相应的启动命令参考同目录的run.sh（具体路径可能需要根据自己的配置修改下）



制作方法参考：https://gist.github.com/chrisdone/02e165a0004be33734ac2334f215380e



# qemu-loongarch-runenv

关于efi uefi bios：[IT之家学院：BIOS、EFI与UEFI详解 - IT之家 (ithome.com)](https://www.ithome.com/html/win10/318460.htm)。

一个比较完整的os内核调试环境来了：https://github.com/foxsen/qemu-loongarch-runenv.git

clone仓库

```
git clone https://github.com/foxsen/qemu-loongarch-runenv.git
cd qemu-loongarch-runenv
```

用file命令查看vmlinux信息如下，这说明龙芯可以启动64位elf格式的内核。

![image-20220312093948962](images/3.11-TODO-%E9%BE%99%E8%8A%AFqemu%E5%8F%8Aqemu-loongarch-runenv.assets/image-20220312093948962.png)

直接运行：

```
./run_loongach.sh
```

成功运行：

![image-20220312104451703](images/3.11-TODO-%E9%BE%99%E8%8A%AFqemu%E5%8F%8Aqemu-loongarch-runenv.assets/image-20220312104451703.png)

但是这里的linux内核没有debug信息，如何在编译内核时保留debug信息呢？

# loongson工具链

![image-20220313101204022](images/3.11-TODO-%E9%BE%99%E8%8A%AFqemu%E5%8F%8Aqemu-loongarch-runenv.assets/image-20220313101204022.png)



下载复制到/opt，解压：

```
sudo xz -d loongarch64-clfs-2021-12-18-cross-tools-gcc-full.tar.xz
sudo tar -xvf loongarch64-clfs-2021-12-18-cross-tools-gcc-full.tar
```

将/opt/cross-tools/bin添加到环境变量

```
sudo vim ~/.bashrc #文件尾添加 export PATH=/opt/cross-tools/bin:$PATH
source ~/.bashrc
echo $PATH
/opt/cross-tools-1218/bin/loongarch64-unknown-linux-gnu-gcc -v#查看版本，是12.0.0
```

由于静态链接，做以下工作：

```shel
sudo rm -f /opt/cross-tools/lib/bfd-plugins/libdep.so
```

**在make之前，需要在shell中，此处不再作为永久设置的环境变量。**

```
export LC_ALL=C
export LANG=C
export LANGUAGE=C
```



# 交叉编译linux内核

[linux内核编译与调试方法 - Casualet - 博客园 (cnblogs.com)](https://www.cnblogs.com/syw-casualet/p/5271369.html)。

```
git clone https://github.com/foxsen/linux.git#clone linux repo with loongarch branch
git checkout loongarch-qemu
```

增加交叉编译工具的环境变量。这里只设置成在当前终端有效，在linux目录下，创建setloongarchenv.sh，写入如下脚本。

```
#!/bin/sh
set -x


CC_PREFIX=/opt/cross-tools
export PATH=$CC_PREFIX/bin:$PATH
export LD_LIBRARY_PATH=$CC_PREFIX/lib:$LD_LIBRARY_PATH
export LD_LIBRARY_PATH=$CC_PREFIX/loongarch64-unknown-linux-gnu/lib/:$LD_LIBRARY_PATH

export ARCH=loongarch
export CROSS_COMPILE=loongarch64-unknown-linux-gnu-


#此处也必须把上文中的临时设置环境变量写上
export LC_ALL=C
export LANG=C
export LANGUAGE=C
set +x
```

[linux 下的 source,sh,./三者区别_lihuaichen的博客-CSDN博客_source和sh区别](https://blog.csdn.net/lihuaichen/article/details/94381785)。

注意不要使用`./setloongarchenv.sh`，而是使用：

```
source setloongarchenv.sh
```

回到linux目录下，

```
cp arch/loongarch/configs/loongson3_defconfig_qemu .config
make menuconfig
```

![image-20220313142524839](images/3.11-TODO-%E9%BE%99%E8%8A%AFqemu%E5%8F%8Aqemu-loongarch-runenv.assets/image-20220313142524839.png)

出现如下界面：

![image-20220312143744264](images/3.11-TODO-%E9%BE%99%E8%8A%AFqemu%E5%8F%8Aqemu-loongarch-runenv.assets/image-20220312143744264.png)

选择kernel hacking

![image-20220312144009329](images/3.11-TODO-%E9%BE%99%E8%8A%AFqemu%E5%8F%8Aqemu-loongarch-runenv.assets/image-20220312144009329.png)

选择compile-time checks and compile options：

![image-20220312144108206](images/3.11-TODO-%E9%BE%99%E8%8A%AFqemu%E5%8F%8Aqemu-loongarch-runenv.assets/image-20220312144108206.png)

选择compile the kernel with debug info：

![image-20220312144148326](images/3.11-TODO-%E9%BE%99%E8%8A%AFqemu%E5%8F%8Aqemu-loongarch-runenv.assets/image-20220312144148326.png)

然后，发现这里不用save，所以直接退出不保存就好了。

接下来，make

```
make -j8
```

在linux目录下，生成vmlinux是300+M的文件，将其复制到qemu-loongarch-runenv/，注意修改后缀名，这是带调试信息的vmlinux

```
cp ${yourpath}/linux/vmlinux vmlinux.sym
```

# 龙芯版gdb

解压`loongarch-cross-gdb_v12.0.50.20220221-git.tar.bz2`至/opt

```
sudo tar -xjvf loongarch-cross-gdb_v12.0.50.20220221-git.tar.bz2 -C /opt/
```

添加环境变量到文件/etc/profile，重启

```
export PATH=/opt/gdb/bin:$PATH
```

* 以后运行，在qemu-loongarch-runenv下，打开终端：

```
./run_loongach.sh -k vmlinux.sym -D
```

在另一个终端下，用龙芯gdb打开，此处最好是在linux目录下，毕竟调试时涉及的目录也在那里。

```
loongarch64-unknown-linux-gnu-gdb vmlinux.sym
(gdb)target remote:1234
(gdb)b start_kernel
(gdb)c
```

![image-20220313155318199](images/3.11-TODO-%E9%BE%99%E8%8A%AFqemu%E5%8F%8Aqemu-loongarch-runenv.assets/image-20220313155318199.png)



# 关于龙芯内核启动

## 龙芯内核入口地址

通过如下命令查看：`readelf -h vmlinux`

![image-20220324191520385](images/3.24-TODO-%E9%BE%99%E8%8A%AFqemu%E5%8F%8Aqemu-loongarch-runenv.assets/image-20220324191520385.png)

![image-20220324191500246](images/3.24-TODO-%E9%BE%99%E8%8A%AFqemu%E5%8F%8Aqemu-loongarch-runenv.assets/image-20220324191500246.png)

## 龙芯head.S分析

见新增代码文件。

# 关于模拟的机器

按ctrl+A、C 调出qemu的monitor模式，按ctrl+alt+1回到qemu模拟的机器。-220-477.15

[使用 monitor command 监控 QEMU 运行状态](https://blog.csdn.net/beckdon/article/details/51074638?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0.topblog&spm=1001.2101.3001.4242.1&utm_relevant_index=3)。

此命令显示进程的内存层次结构。在QEmu的提交日志中，以下条目创建此功能的第一个版本。`info mtree` 所做的是打印系统内存到不同设备的映射 . 还表示了这些设备的层次结构。

```
(qemu) info mtree
address-space: cpu-memory-0
address-space: memory // cpu physical memory address space, access via load/store instructions via corresponding virtual addresses
  0000000000000000-ffffffffffffffff (prio 0, i/o): system
    0000000000000000-000000000fffffff (prio 0, ram): alias loongarch.lowram @loongarch.ram 0000000000000000-000000000fffffff //low 256MB memory
    0000000010000000-00000000100000ff (prio 0, i/o): loongarch_pch_pic.reg32_part1 // LS7A1000's interrupt controller regs
    0000000010000100-000000001000039f (prio 0, i/o): loongarch_pch_pic.reg8
    00000000100003a0-0000000010000fff (prio 0, i/o): loongarch_pch_pic.reg32_part2
    000000001001041c-000000001001041f (prio -1000, i/o): pci-dma-cfg
    0000000010013ffc-0000000010013fff (prio -1000, i/o): mmio fallback 1
    00000000100d0000-00000000100d00ff (prio 0, i/o): ls7a_pm  // LS7A1000 power management functions
      00000000100d000c-00000000100d0013 (prio 0, i/o): acpi-evt
      00000000100d0014-00000000100d0017 (prio 0, i/o): acpi-cnt
      00000000100d0018-00000000100d001b (prio 0, i/o): acpi-tmr
      00000000100d0028-00000000100d002f (prio 0, i/o): acpi-gpe0
      00000000100d0030-00000000100d0033 (prio 0, i/o): acpi-reset
    00000000100d0100-00000000100d01ff (prio 0, i/o): ls7a_rtc
    0000000018000000-0000000018003fff (prio 0, i/o): alias isa-io @io 0000000000000000-0000000000003fff // legacy io mapped to 0x1800-0000
    0000000018004000-000000001800ffff (prio 0, i/o): alias pcie-io @gpex_ioport_window 0000000000004000-000000000000ffff // pcie io mapped here
    000000001c000000-000000001c3fffff (prio 0, rom): loongarch.bios // bios start at 0x1c000000
    000000001c400000-000000001c4fffff (prio 0, rom): fdt
    000000001e020000-000000001e020007 (prio 0, i/o): fwcfg.data
    000000001e020008-000000001e020009 (prio 0, i/o): fwcfg.ctl
    000000001fe001e0-000000001fe001e7 (prio 0, i/o): serial // uart port
    0000000020000000-0000000027ffffff (prio 0, i/o): alias pcie-ecam @pcie-mmcfg-mmio 0000000000000000-0000000007ffffff //pcie config mapped
    000000002ff00000-000000002ff00007 (prio 0, i/o): loongarch_pch_msi //LS7A MSI interrupt
    0000000040000000-000000007fffffff (prio 0, i/o): alias pcie-mmio @gpex_mmio_window 0000000040000000-000000007fffffff //pcie memory mapped
    0000000090000000-000000017fffffff (prio 0, ram): alias loongarch.highmem @loongarch.ram 0000000010000000-00000000ffffffff // high part ram

...

address-space: IOCSR  // a special address space accessed via iocsrrd/iocsrwr instructions.
  0000000000000000-ffffffffffffffff (prio 0, i/o): iocsr
    0000000000000000-0000000000000427 (prio 0, i/o): iocsr_misc  // only FEATURE_REG(0x8)/VENDOR_REG(0x10)/CPUNAME_REG(0x20)/MISC_FUNC_REG(0x420) read simulated
    0000000000001000-00000000000010ff (prio 0, i/o): loongarch_ipi
    0000000000001400-0000000000001cff (prio 0, i/o): loongarch_extioi // not every part of this simulated, only the following subregions, that is, no legacy irqs, only extended irqs
      0000000000001400-00000000000014bf (prio 0, i/o): loongarch_extioi.nodetype
      00000000000014c0-000000000000167f (prio 0, i/o): loongarch_extioi.ipmap_enable
      0000000000001680-0000000000001bff (prio 0, i/o): loongarch_extioi.bounce_coreisr
      0000000000001c00-0000000000001cff (prio 0, i/o): loongarch_extioi.coremap

memory-region: gpex_ioport_window //pcie IO space
  0000000000000000-000000000000ffff (prio 0, i/o): gpex_ioport_window
    0000000000000000-000000000000ffff (prio 0, i/o): gpex_ioport
      0000000000004000-000000000000401f (prio 1, i/o): virtio-pci

memory-region: pcie-mmcfg-mmio //pcie cfg space
  0000000000000000-000000001fffffff (prio 0, i/o): pcie-mmcfg-mmio

memory-region: gpex_mmio_window  //pcie memory space
  0000000000000000-ffffffffffffffff (prio 0, i/o): gpex_mmio_window
    0000000000000000-ffffffffffffffff (prio 0, i/o): gpex_mmio
      0000000040040000-0000000040043fff (prio 1, i/o): virtio-pci
        0000000040040000-0000000040040fff (prio 0, i/o): virtio-pci-common-virtio-net
        0000000040041000-0000000040041fff (prio 0, i/o): virtio-pci-isr-virtio-net
        0000000040042000-0000000040042fff (prio 0, i/o): virtio-pci-device-virtio-net
        0000000040043000-0000000040043fff (prio 0, i/o): virtio-pci-notify-virtio-net
      0000000040044000-0000000040044fff (prio 1, i/o): virtio-net-pci-msix
        0000000040044000-000000004004403f (prio 0, i/o): msix-table
        0000000040044800-0000000040044807 (prio 0, i/o): msix-pba
...
```

如果load/store访问了某个物理地址，但它在 cpu-memory-0 地址空间中不存在，则会触发异常。

对于某些存在的地址，访问也可能无效。对于io地址，它取决于qemu是否处理了那一段的所有地址。例如[0-0x428)是iocsr_misc，访问这段地址，将被loongarch_qemu_ops处理。

```
memory_region_init_io(&env->iocsr_mem, OBJECT(la_cpu), &loongarch_qemu_ops,
                          NULL, "iocsr_misc", IOCSR_MEM_SIZE);
```

老师还讲了loongarch_qemu_ops具体的内容。参考源码

![image-20220415220901104](images/4.15-TODO-%E9%BE%99%E8%8A%AFqemu%E5%8F%8Aqemu-loongarch-runenv.assets/image-20220415220901104.png)

# 中断层级

外部中断大致通过这样的路径进入cpu：中断源 -> level3 -> level 2 -> level 1

```
- level 1: CPU core interrupt controller(HWI0-HWI7)
- level 2: extended Interrupt controller(extioi_pic in qemu, 256 irqs)
- level 3: LS7A1000 interrupt controller(pch_pic in qemu, 64 irqs; pch_msi, 192 irqs, refer to 7A1000 user manual)
- interrupt sources:
    - 4 PCIE interrupt output connect to pch_pic 16,17,18,19
    - LS7A UART/RTC/SCI connect to pch_pic 2/3/4
```

英文缩写注：

* pic，可编程中断控制器。pic一般指可编程中断控制器。 可编程中断控制器是微处理器与外设之间的中断处理的桥梁，由外设发出的中断请求需要中断控制器来进行处理。
* pch，可以理解成南桥？
* msi，message signal interrupt, 是PCI设备通过写一个特定消息到特定地址,从而触发一个CPU中断。
* intc，中断控制器的功能就是在有多个[中断源](https://baike.baidu.com/item/中断源)的系统中，接收外部的[中断请求](https://baike.baidu.com/item/中断请求)，并进行判断，选中当前优先级最高的中断请求，再将此请求送到CPU的INTR端;当CPU响应中断并进入中断[子程序](https://baike.baidu.com/item/子程序)的处理过程后，中断控制器仍负责对外部中断请求的管理。比如当某个外部[中断请求](https://baike.baidu.com/item/中断请求)的优先级高于当前正在处理的[中断优先级](https://baike.baidu.com/item/中断优先级)时，中断控制器会让此中断通过而到达CPU的INTR端，从而实现中断的嵌套，反之，对其他级别较低的中断则禁止。
* ht，hypertransport，高速串行总线技术。
* extioi ：扩展 io 中断

关于cpu核内中断控制器：

* 参考龙芯架构第6章。
* CPU本身产生的中断直接连接到这个intc (HWI0-HWI7)，例如6.1节内容。

关于extioi中断控制器：

* extioi 代表扩展 io 中断，见3A5000用户手册11.2节。
* 每个 extioi irq 都映射到 CPU 核心 intc 输入之一（HWI0-7）
  * 见readme
* qemu的实现：
  * readme















