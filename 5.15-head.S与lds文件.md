# head.S

## 龙芯的head.S

在linux/arch/loongarch/kernel/head.S

```
SYM_CODE_START(kernel_entry)            # kernel entry point
    /* Config direct window and set PG */
    li.d        t0, CSR_DMW0_INIT   # UC, PLV0, 0x8000 xxxx xxxx xxxx,UC应该是uncached,li load imm,d表示64位双字
    csrwr       t0, LOONGARCH_CSR_DMWIN0
    li.d        t0, CSR_DMW1_INIT   # CA, PLV0, 0x9000 xxxx xxxx xxxx,CA应该是cached,li load imm
    csrwr       t0, LOONGARCH_CSR_DMWIN1

    /* We might not get launched at the address the kernel is linked to,
     * so we jump there. We must setup direct access window before this.
     */
    la.abs      t0, 0f  //把标号0的地方的代码地址装入寄存器t0
    jirl        zero, t0, 0 //跳转到t0，此时t0是链接是用的高位没有抹去0的虚拟地址，而前面设置的窗口保证了它能访问到bios将其装入的那段物理内存
0:
    la      t0, __bss_start     # clear .bss
    st.d        zero, t0, 0
    la      t1, __bss_stop - LONGSIZE
```

```
.global _stext;//SYM_ENTRY(_stext, SYM_L_GLOBAL, SYM_A_NONE)
;
_stext:
.section ".ref.text", "ax"//__REF
.global kernel_entry;//SYM_CODE_START(kernel_entry)
.align 2;
kernel_entry:
	la.abs		t0, 0f						//la.abs，Load address through absolute address，0f标签加载到t0
	jirl		zero, t0, 0					//跳转到t0,zero表示寄存器r0，值总是为0
0:
	la		t0, __bss_start		# clear .bss//__bss_start地址装入t0，__bss_start全局的未初始化变量
	st.d		zero, t0, 0					//0写入[to]+0虚拟地址
	la		t1, __bss_stop - LONGSIZE		//__bss_stop - LONGSIZE地址装入t1
1:
	addi.d		t0, t0, LONGSIZE			//[t0]+LONGSIZE-->[t0]
	st.d		zero, t0, 0					//0写入[to]+0虚拟地址
	bne		t0, t1, 1b						//[t0]!=[t1]?pc=1b，b为backward，1的位置

	la		t0, fw_arg0						//fw_arg0地址装入t0
	st.d		a0, t0, 0		# firmware arguments//[a0]写入[to]+0虚拟地址
	la		t0, fw_arg1						//fw_arg1地址装入t0
	st.d		a1, t0, 0					//[a1]写入[t0]+0虚拟地址
	la		t0, fw_arg2						//fw_arg2地址装入t0
	st.d		a2, t0, 0					//[a2]写入[t0]+0虚拟地址
	la		t0, fw_arg3	 					//fw_arg3地址装入t0
	st.d		a3, t0, 0					//[a3]写入[t0]+0虚拟地址
	/* Config direct window and set PG */
	li.d		t0, CSR_DMW0_INIT	# UC, PLV0, 0x8000 xxxx xxxx xxxx
	csrwr		t0, LOONGARCH_CSR_DMWIN0
	li.d		t0, CSR_DMW1_INIT	# CA, PLV0, 0x9000 xxxx xxxx xxxx
	csrwr		t0, LOONGARCH_CSR_DMWIN1
	......
	la		tp, init_thread_union					//tp是r2。
	PTR_LI		sp, (_THREAD_SIZE - 32 - PT_SIZE)	//li.d，(_THREAD_SIZE - 32 - PT_SIZE)存入[sp]。初始化sp寄存器
	PTR_ADDU	sp, sp, tp							//add.d [sp]+[tp]->[sp]
	set_saved_sp	sp, t0, t1						//将sp存入了[kernelsp]
	PTR_ADDIU	sp, sp, -4 * SZREG	# init stack pointer//add.d [sp]+(-4)*8
	bl		start_kernel							//跳转到start_kernel
	
.type kernel_entry 0;//不以任何方式标记符号。支持它只是为了完整性。
.size kernel_entry, .-kernel_entry//结束并计算大小：SYM_CODE_END(kernel_entry)

.global kernel_entry_end;
;
kernel_entry_end://SYM_ENTRY(kernel_entry_end, SYM_L_GLOBAL, SYM_A_NONE)
```



每条指令怎么看：

* 在龙芯gdb-binutils里：opcodes/loongarch-opc.c的loongarch_macro_opcodes部分。
* 每条指令具体的作用：opcodes/loongarch-coder.c的loongarch_expand_macro实现。
* gas/config/tc-loongarch.c的assember_macro_helper。
* [sourceware.org: Free software! Get your fresh hot free software!](https://sourceware.org/)。查手册。

关于其中一些宏定义，还需要全局搜索可以看到，比如在Documentation/asm-annotations.rst中有SYM_ENTRY的相关描述。

* SYM_ENTRY(_stext, SYM_L_GLOBAL, SYM_A_NONE)

![image-20220325150908857](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220325150908857-16484371098631.png)

![image-20220325150937902](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220325150937902-16484371119462.png)

SYM_ENTRY(_stext, SYM_L_GLOBAL, SYM_A_NONE)，seL4应该指的是.global _stext这样的东西，无对齐要求。

.global _stext;

;

_stext:

* __REF在seL4中，应该可以直接写成.section的形式。

![image-20220328111204436](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220328111204436-16484372131023.png)

* SYM_CODE_START(kernel_entry)

SYM_CODE_START(kernel_entry)---SYM_START(kernel_entry,SYM_L_GLOBAL, SYM_A_ALIGN)---SYM_ENTRY(name, linkage, align...)---

.global kernel_entry;

.align 2;

kernel_entry:

![image-20220328140105935](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220328140105935.png)

![image-20220328140251525](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220328140251525.png)

![image-20220328140336210](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220328140336210.png)

![image-20220328140547373](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220328140547373.png)

![image-20220328140621901](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220328140621901.png)

![image-20220328140917320](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220328140917320.png)



![image-20220328171357275](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220328171357275.png)

kernelsp载入\temp，LONG_S==st.d，即stackp写入[kernelsp]。外部调用宏，也就是将sp存入了[kernelsp].

* SYM_CODE_END(kernel_entry)

![image-20220328172759109](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220328172759109.png)

即SYM_END(kernel_entry, SYM_T_NONE)

![image-20220328172931110](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220328172931110.png)

![image-20220328192024954](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220328192024954.png)

即	

```
.type kernel_entry 0;//不以任何方式标记符号。支持它只是为了完整性。
.size kernel_entry, .-kernel_entry
```

.type用法：[Type (Using as) (sourceware.org)](https://sourceware.org/binutils/docs/as/Type.html#Type)。

## seL4的head.S

.section 定义内存段。.boot.text：

![image-20220325171923329](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220325171923329.png)

关于ax，很多地方都出现，此处也保留。

.global关键字用来让一个符号对连接器可见，可以供其他连接对象模块使用。
.global _start 让_start符号成为可见的标示符，这样连接器就知道跳转到程序中的什么地方并开始执行。linux寻找这个 _start标签作为程序的默认进入点。

.extern kernel_stack_alloc来自kernel/src/kernel/stack.c

.extern __global_pointer$ 栈指针？它好像在kernel/src/arch/arm/common_arm.lds被定义。[Linux下的lds链接脚本详解](https://www.cnblogs.com/li-hao/p/4107964.html)。

head.S文件：

```head.S
见seL-LA
```

# common_loongarch.lds

## lds指导生成elf文件，elf文件信息查看

riscv的kernel.elf文件查看：`readelf -h kernel.elf`

![image-20220327232428340](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220327232428340.png)

入口点地址，即kernel的虚拟地址的入口。这个地址也是lds文件中的KERNEL_ELF_BASE(虚拟地址)。`objdump -h kernel.elf`

![image-20220327232348310](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220327232348310.png)













## lds文件技术积累及编写

[__attribute__之section详解_張公㜽的博客-CSDN博客_attribute section](https://zhangjianfa.blog.csdn.net/article/details/95947358?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5.pc_relevant_default&utm_relevant_index=10).lds文件应该是自动生成的，放到最后看。

[Linux下的lds链接脚本详解](https://www.cnblogs.com/li-hao/p/4107964.html)。总之，输入多个文件，链接成一个elf文件

[对GNU的.lds连接脚本文件的分析 - Linux文档专区-Chinaunix](http://bbs.chinaunix.net/forum.php?mod=viewthread&tid=1963790&highlight=lds%2B%BD%C5%B1%BE)。

这里面很多头文件怎么找？

#include<config.h>但是在config.h中并没有看到很有用的信息。

![image-20220326000033707](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326000033707.png)

#include <hardware.h>??

通过find命令，看到：

![image-20220326104353012](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326104353012.png)

在cmakelists.txt中，include了相应架构下的内容。结合上文，hardware.h应该是指

![image-20220326104249867](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326104249867.png)

如果将这4个hardware.h改名，在编译平台相关代码即ninja的时候，会先报错：找不到arch/machine/hardware.h。此处说明arch/object/structures.h引用了arch/machine/hardware.h头文件。

![image-20220326154140407](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326154140407.png)

将arch/machine/hardware.h恢复。再次ninja，找不到mode/hardware.h。此处说明arch/machine/hardware.h 引用了64/mode/hardware.h。

![image-20220326154455174](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326154455174.png)

将64/mode/hardware.h恢复。再次ninja，找不到hardware.h。此处说明/include/machine.h下引用了/include/hardware.h

![image-20220326154942420](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326154942420.png)

事实证明，32/mode/hardware.h未被调用。此处无用。

因此，直接hardware.h，应该对应：

![image-20220326161711007](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326161711007.png)

即

![image-20220326162012785](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326162012785.png)

machine/hardware.h，应该对应：

![image-20220326162124350](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326162124350.png)

即

![image-20220326162249044](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326162249044.png)

mode/hardware.h，应该对应：

![image-20220326162313282](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326162313282.png)

即

![image-20220326162337966](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326162337966.png)

#include <sel4/plat/api/constants.h>???

![image-20220326171610761](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326171610761.png)

对应：

![image-20220326172156969](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326172156969.png)

即：

![image-20220326172218258](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220326172218258.png)

#include  <plat/machine/devices_gen.h>？？

![image-20220327103455901](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220327103455901.png)

在build时候生成。

![image-20220327111222728](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220327111222728.png)

![image-20220327115327018](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220327115327018.png)

这是PPTR_TOP，因为KERNEL_ELF_PADDR_BASE小于1G，它模1G没变化。



* VMA(virtual memory address虚拟内存地址或程序地址空间地址)

* LMA(load memory address加载内存地址或进程地址空间地址)

  ![image-20220327203953550](images/3.25-TODO-seL4%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.assets/image-20220327203953550.png)



[seL4内核入口 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/466424606)。

直接看elf文件

```
OUTPUT_ARCH(loongarch)//输出架构
ENTRY(_start)//指定输出可执行文件的起始代码段为_start


```





