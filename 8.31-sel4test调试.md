在projects/sel4test/apps/sel4test-driver/src/main.c的sel4test_run_tests函数，跑每个test的函数。通过p *tests[i]可以查看test具体内容。

先初始化，再运行，再结束。

有些测试会创建新线程，新线程统一进入projects/sel4test/apps/sel4test-tests/src/main.c的main()函数，该函数的find_test函数会找到该测试。result = test->function((uintptr_t)&env);



# 关于test18的调试--通过

在170行，wait_for_helper(&waiter_thread);处卡住。

系统调用，和时间中断同时产生，如果先处理时间中断，我保存estat只保留ecode部分，把中断位mask掉，但是在中断返回后仍返回到系统调用的位置，会继续trap，再去检查estat，发现又同时置起，陷入死循环。

考虑先处理系统调用，再处理中断，最后是例外。 

它走了fastpath，fastpath的恢复现场函数和之期的不通用，在此处卡死，修改后可以运行。

slowpath的handleSyscall也有问题，不能设置刷新所有tlb，只刷新当前线程的tlb。





# 关于test36的调试

test36的函数在projects/sel4test/apps/sel4test-tests/src/tests/fpu.c:test_fpu_multithreaded。

发现时钟中断和系统调用总是同时出现，时钟中断没有单独出现过。开qemu调试信息，查看ecfg的时钟中断没有打开。原因是初始化线程时候忘记设置ecfg。



# 关于test39的调试

测试函数在projects/sel4test/apps/sel4test-tests/src/tests/frames.c的test_unmap_on_delete（）函数。

334行卡死。











