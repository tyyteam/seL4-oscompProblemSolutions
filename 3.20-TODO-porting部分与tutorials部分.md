# porting

seL4网站：[Porting seL4 to a new platform ](https://docs.sel4.systems/projects/sel4/porting)。

FAQ：[Frequently Asked Questions on seL4 ](https://docs.sel4.systems/projects/sel4/frequently-asked-questions.html)。

[Tutorials | seL4 docs](https://docs.sel4.systems/Tutorials/)。感觉这里面的seL4 mechanisms tutorials有点用。

libsel4 API：[API Reference | seL4 docs](https://docs.sel4.systems/projects/sel4/api-doc.html)。

知乎博客：https://zhuanlan.zhihu.com/p/466424606。

csdn博客：[sel4源码解析（一） - sel4内核对象_Mr0cheng的专栏-CSDN博客_sel4内核](https://blog.csdn.net/Mr0cheng/article/details/104338058)。

## Porting seL4 to a new platform

根据网页：[Porting seL4 to a new platform ](https://docs.sel4.systems/projects/sel4/porting)。

tree命令，将当前目录打印到某文件。

```
tree [-L n]> fileTree.txt #-L n为限制层级，e.g.-L 2，重定向输出至fileTree.txt
```

根目录：

```
.
├── build
├── CAVEATS-generic.md
├── CAVEATS-ia32.md
├── CHANGES
├── CMakeLists.txt
├── CODE_OF_CONDUCT.md
├── config.cmake
├── configs
├── CONTRIBUTING.md
├── CONTRIBUTORS.md
├── FindseL4.cmake
├── gcc.cmake
├── gdb-macros
├── include
├── libsel4 #libsel4/sel4_plat_include/<platform>/sel4/plat/api/constants.h
├── LICENSE.md
├── LICENSES
├── llvm.cmake
├── manual
├── README.md
├── src
├── tools
├── treefile.txt
└── VERSION
```

* DTS修改：在tools/dts/update-dts.sh
* Hardware generation script修改：在tools/hardware.yml
  * Drivers：/src/drivers/
  * Drivers：/include/drivers/
* kernel：在libsel4/sel4_plat_include/\<platform>/sel4/plat/api/constants.h添加支持

* CMake-Build System：在kernel/src/plat/\<platform>/config.cmake，以及tools/seL4/cmake-tool/helpers/application_settings.cmake，还有tools/seL4/elfloader-tool/CMakeLists.txt
* elf-loader：在tools/seL4/elfloader-tool/src/plat/\<platform>/sys_fputc.c，以及tools/seL4/elfloader-tool/include/plat/\<platform>/platform.h
* seL4test：在sel4test/projects/util_libs/libplatsupport/plat_include/\<platform>/platsupport/plat下添加头文件支持，在sel4test/projects/util_libs/libplatsupport/src/plat/\<platform>/下添加相应源文件。

# tutorials部分

参考网址：[Tutorials | seL4 docs](https://docs.sel4.systems/Tutorials/)。

先建立文件夹：

```
mkdir sel4-tutorials-manifest
cd sel4-tutorials-manifest
repo init -u https://github.com/seL4/sel4-tutorials-manifest
repo sync
```

在文件夹下，输入如下命令，查看相应的内容，选择参数，自动生成文件。

```
./init -h
```

例如：

```
./init --tut hello-world # 自动生成hello-world，hello-world_build
cd hello-world
ninja
./simulate
```

vscode跳转到上次位置：`shift+alt+-`

## helloworld

```
./simulate --extra-qemu-args="-s -S"
```

好像不能直接读入两个符号表。启动gdb 读入kernel的符号表：

```
gdb kernel/kernel.elf
target remote:1234
```

获取程序入口信息，设置断点

```
info files
```

![image-20220310163019083](images/tmp.assets/image-20220310163019083.png)

设置断点：

```
b *0x1002ea
```

另外，保存断点：

```
save breakpoint ${BPfilename}
```

下次调试文件时，在指定文件的同时，指定断点文件

```
gdb ${filename} -X ${BPfilename}
```

汇编好像用的AT&T语法。[汇编中 $ 和 % 符号的作用-andyhzw-ChinaUnix博客](http://blog.chinaunix.net/uid-28458801-id-3555479.html)。

AT&T语法中，$表示立即数，%表示寄存器。mov $4, %eax，是把4送入eax。



## capability

Capabilities：类似于句柄？

CNodes：类似于capabilities的数组？

CSlots：类似于CNodes中每个元素指针？

CSpace：属于一个线程的capability地址范围。根任务总是有一个指向CNode的root Capability，可以利用root capability查找对应CSlot中指向的capability。



## Untyped

### Background

启动阶段创建对象的cap，以及其他物理资源，在启动时会传递给root task

除了用来创建根任务的cap，指向其他可得物理资源的cap会传递给root task，这些cap指向的是untyped memory。无类型cap是指向无类型内存的cap。无类型cap可以重新指向内核其他对象，或者更小的无类型内存。

device：boolean类型的属性，指示内存是否可被内核写，这片内存可能不由ram设备支持而是其他设备支持的内存，或者是ram内无法由内核寻址的空间。device为true的无类型cap只能重新指向帧对象（可以被映射到虚拟内存的物理内存帧），但是不能被内核写。

### Initial state

seL4_BootInfo描述所有无类型cap，提供给root task，包括大小，device untyped？以及物理地址。

### Retyping

 seL4_Untyped_Retype，可以用来创建新的cap。创建出来的新cap提供对原cap内存子区域的访问，要么是更小区域无类型cap，要么是指向特定类型的新对象cap。新cap是原cap的children。

无类型cap以贪心的增量方式retype，这有助于内存的高效利用。每个无类型cap维护一个watermark，watermark包含retype前的地址和retype开始时的地址。在retype时候，watermark首先是对象的对其地址，最后是末地址。创建对象要按照占据内存从大到小排序创建。

![image-20220314224747372](images/3.11-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/image-20220314224747372.png)

#### Types

libsel4下，可以找到对象的类型的描述。有些是架构特有的，其他的是各个架构都有的。然后讲了上面函数的内容。

#### Size

该函数的size参数的一些情况：

* 多数对象都是固定的size，内核忽略改参数。
* seL4_UntypedObject 和seL4_SchedContextObject允许可变size，由参数指定。2的size次方。
* seL4_CapTableObject 也是可变size，改参数是slot数量。

`For retype, it is enough to remember that the parameter size_bits means the object will measure 2size_bits bytes, and for seL4_CapTableObject that you are requesting 2size_bits slots (you can compute the size in bytes by taking 2size_bits + seL4_SlotBits`

#### Root, node_index & node_depth

node_depth设为0，意味着invocation方式寻址。index忽略。

node_depth不设为0，直接寻址。当前线程的scpace root作为root，index指向CNode，depth是index指向CNode的大小。为多层cspace设计的。

#### Node_offset

CNode中选的CSlot偏移

#### Num_caps

该函数可以创建多个cap和object。

注意：untyped必须足够大来装入所有需要的内存。要有连串的空闲CSlot放cap。

### 一些问题

 tut代码中， seL4_Untyped_Retype(child_untyped, seL4_TCBObject, 0, seL4_CapInitThreadCNode, 0, 0, child_tcb, 1);

为啥是CapInitThreadCNode？初始化时候，还没有创建其他线程。

## Virtual memory

[地址映射_zyn19950120的博客-CSDN博客_地址映射](https://blog.csdn.net/zyn19950120/article/details/77647761?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=2)。

[C语言字节对齐详解_OopspoO的博客-CSDN博客_字节对齐](https://blog.csdn.net/cclethe/article/details/79659590)。

### Background

seL4不提供虚拟内存管理，除了用来操作硬件分页结构的内核原语。**用户提供中间分页结构、映射和取消映射页面的服务。**

用户可自由定义地址空间布局，遵守限制：`On most 32-bit platforms, this is 0xe0000000 and above`，kernelBase变量。

### Paging structures

VSpace：根任务初始化时候的虚拟存储对象。由seL4_CapInitThreadVSpace指向该结构。各种arch下的object type不同。它是top-level的。

![image-20220316095803612](images/3.15-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/image-20220316095803612.png)

除了top-level的，中间硬件虚拟存储对象也被用来映射页。

![image-20220316100248653](images/3.15-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/image-20220316100248653.png)

可以通过调用来确定是否映射。`seL4_X86_PDPT_Map(pdpt, seL4_CapInitThreadVSpace, TEST_VADDR, seL4_X86_Default_VMAttributes)`该函数的三个参数：VSpace，vaddr，vattributes，第一个参数是被映射的对象。vattributes是映射时高速缓存的属性，与架构相关，libsel4中可以看到。

![image-20220316102906890](images/3.15-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/image-20220316102906890.png)

如果虚拟地址参数与映射对象大小不是对齐的，seL4将会mask out任何未使用的位。例如4KB的页被映射到0xDEADBEEF，最终会被映射到0xDEADB000。

### Pages

对于特定的虚拟地址range，一旦所有的中间映射结构被设计好，通过调用帧的cap，该帧就可以被映射进去了。代码片段展示了将frame映射到test_vaddr。

![image-20220316103522679](images/3.15-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/image-20220316103522679.png)

libsel4中的函数seL4_MappingFailedLookupLevel决定哪一级映射结构缺失。多级映射，每一级要有一个cap，每个cap只能追踪一级映射。上面函数中还有个rights参数，它决定着映射权限。

#### Types and sizes

页类型和数量与架构有关。x86和ARM架构上，各个size的页类型不同。在RISCV上，页类型相同但大小不尽相同。通过改变配置来改变页大小。

### 疑问

mapping里涉及的几个参数是怎么理解？
pdpt是“pd的目录”的cap吗，对应seL4_X86_PDPT_Map
pd是pd的cap，对应seL4_X86_PageDirectory_Map
pt是pt的cap，对应seL4_X86_PageTable_Map
具体页cap，对应seL4_X86_Page_Map

## Threads

[sel4源码解析（六） - 进程_Mr0cheng的博客-CSDN博客](https://blog.csdn.net/Mr0cheng/article/details/104338064)。

### Background

#### TCB

sel4用线程来表示执行上下文并管理处理器时间。sel4中的线程由线程控制块TCB对象实现，每个线程有个线程控制块。

TCB包含如下信息：

* 优先级别以及最大控制优先级
* 寄存器状态和浮点上下文
* cspace 的cap
* vsapce 的cap
* 端点cap，用于发送错误消息
* reply cap，回复cap？

#### Scheduling model

sel4调度器调度thread到某个处理器上运行，调度算法是基于优先级的round-robin调度。调度器会选择可以运行的threads，基于这样的条件：在任何IPC操作上不会被阻止并可以恢复。

##### Priorities

0-255的优先级，调度器选择最高的优先级。libsel4中有编码。kernel/libsel4/include/sel4/constants.h。

TCB还有个MCP属性。设置TCB优先级的时候，必须准确提供tcb的cap。优先级由tcb的mcp检查，如果被设置的优先级过高，就设置失败。根任务最初的priority和MCP都设为seL4_MaxPrio。

##### Round robin时间片轮转

多个tcb可以运行，优先级相同时，它们以先进先出的round-robin方式被调度。内核时间按照固定时间量tick的数量来计算。tcb有个时间片字段，表示被抢占前可以执行的tick数。内核时间驱动，被配置为出发周期性中断的方式，中断会标记每个tick。当时间片耗尽时，该算法起作用。thread通过seL4_Yield放弃当前的时间片占用。

##### Domain scheduling

为了保证机密性，sel4提供了顶级分层调度程序，它能够提供调度分区(即域)的静态调度，周期性调度。在编译时，域将被静态配置为不可抢占式的周期性调度，这会导致完全确定性的调度。

线程可以被分配进域，线程只有在域活跃时才会被调度。跨域的IPC需要等待域切换完成，域间的seL4_Yield不被允许。假如调度了域，但是域内没有运行thread，域内特定的空闲线程将运行直到发生域切换。

通过seL4_DomainSet cap，将thread加入domain。

#### Thread Attributes

sel4线程在tcb的invocation中被配置。

### Exercise

#### CapDL Loader

之前的tutorials都在根任务中，起始scpace布局是由sel4 boot 程序设置的。这个教程使用capDL loader，它是分配静态配置对象和cap的root task。

capDL loader能够解析对系统和相关elf二进制文件的静态描述，从而分配静态配置对象和cap。它主要用于camkes项目也用于教程减少冗余代码。你创建的程序最终会有它自己的cspace和vspace，它们与root task是分开的，这意味着seL4_CapInitThreadVSpace这样的cslot在capDL loader加载的程序中是无意义的。

#### Configure a TCB

debug syscalls在libsel4中可以找到。seL4_DebugDumpScheduler()可以转储调度器的状态。

问题：

![QQ图片20220316222024](images/3.15-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/QQ%E5%9B%BE%E7%89%8720220316222024.png)

看注释里说这是current thread的root_cnode和root_vspace。不是创建了一个新的tcb么，不用新指定root_cnode吗？还是说，这是子线程关系，所以用的父线程一样的root_cnode?--应该是

![QQ图片20220316222031](images/3.15-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/QQ%E5%9B%BE%E7%89%8720220316222031.png)

另外，内核启动以后，未创建新线程前，不是只有一个线程么，这里有rootserver和idle可以理解，为啥还有tcb_threads线程？

试了下helloworld，确实只有2个：

![image-20220316235054280](images/3.15-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/image-20220316235054280.png)

即从helloworld里打印是没有的，搜了一下，感觉是某处创建了这个线程。

#### Change priority via seL4_TCB_SetPriority

新建线程的priority为0，但loader创建的线程优先级是254，改变线程优先级才能被轮询算法调度。改变其他线程优先级的线程必须有权限。

#### set thread's register set.

TCB还需设置初始寄存器才能运行，`set the program counter and stack pointer to valid values`。`libsel4utils`包含一些设置寄存器的函数，它是与平台无关的方式设置的。假设栈在所有平台上都是向下增长的。

[X86-64寄存器和栈帧_Rain2536的博客-CSDN博客_rsp寄存器](https://blog.csdn.net/dayancn/article/details/51328959?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_paycolumn_v3&spm=1001.2101.3001.4242.1&utm_relevant_index=3)。

![QQ图片20220317104504](images/3.16-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/QQ%E5%9B%BE%E7%89%8720220317104504.jpg)

#### Start the thread

seL4_TCB_Resume即可

#### Passing arguments

目前参数全0，用函数sel4utils_arch_init_local_context可以传递参数。

#### Resolving a fault 处理错误

现在创建的thread还没有fault handler。本例子中，尝试发送错误信息，是个vm错误。新线程尝试访问0x2，它是非法未映射的地址。显示了PC值，出故障0x401e66。

错误状态寄存器也是输出，可以使用架构手册查看。另外，内核打印了堆栈转储信息。转储信息内容可以配置。

在加载的elf文件上，用objdump检查导致故障的指令，elf文件位于`threads_build/threads`,

![img](images/3.16-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/$YT_T_A02CL%5B%5BCYP%7BGK%5B0Q6.png)

此处可看出将arg2内的值取出放入eax。

最后正确传递参数，新线程运行起来了，输出了42

![image-20220317153723305](images/3.16-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/image-20220317153723305.png)

## IPC

### Background

IPC是微内核进程间，同步传输少量数据和cap的机制。在sel4中，IPC的实施依赖于endpoints内核对象，该对象是通用通讯端口。endpoint上的函数调用被用来发送和接收IPC消息。

endpoint由等待发送或接收消息的线程队列组成。如果有n个线程在endpoint队列上等待消息，此时有n个线程发送消息，这n个等待线程就会收到消息并wake up，如果n+1个线程发送消息，多一个进入等待队列。

#### system calls

seL4_Send发送，阻塞，直到有线程接收。

seL4_NBSend发送，只有接收线程阻塞等待接收，才能成功发送，不返回是否发送成功的消息。

seL4_Recv 发送消息。

seL4_NBRecv 发送消息，应该是只有线程阻塞发送，才能接收成功。

seL4_Call 是系统调用，结合了seL4_Send和seL4_Recv，但有个区别：使用该函数的发送线程会被回复cap（一次性cap）阻塞，而不是endpoint自己阻塞，直到发送线程成功发送并接收到回复。在客户端服务器模式下，客户使用seL4_Call 发出请求，服务器可以向正确的客户返回明确的回复。

reply cap存储在接收线程TCB的内部。seL4_Reply系统调用这个cap，它将向客户发送IPC并唤醒它。seL4_ReplyRecv也是这样，只不过在组合系统调用中，它回复消息并在endpoint阻塞。

TCB仅有单独空间存放reply cap，如果服务器需要回复多个请求，[`seL4_CNode_SaveCaller`](https://docs.sel4.systems/ApiDoc.html#save-caller)可以用来存储reply cap到接收者cspace的空槽中。

#### IPC Buffer

每个线程有个缓冲区，包含IPC消息（由数据和cap组成），发送者指明消息长度，内核复制该数值给接收者。

#### Data transfer

IPC buffer有一些消息寄存器用来传递数据，每个寄存器是word 大小，最大消息size在libsel4的seL4_MsgMaxLength中。

消息可以用seL4_SetMR装入IPC缓冲区，用get函数提取出来。短消息被送入寄存器不需要复制操作。seL4_FastMessageRegisters常数中提到了能够放入寄存器的字的数量。

需要使用的消息寄存器数量，必须在length字段设置，该字段在seL4_MessageInfo_t结构体中。

#### Cap transfer

除了消息，IPC在每次进程通讯时，还可以发送cap。即 cap transfer。传递的cap数量是extraCaps，在seL4_MessageInfo_t结构体中。

接收者收到的cap权限与接收者对endpoint的权限相同，这样就可以通过各种权限的endpoint来得到各种权限的cap了？？？？？？？？

#### Capability unwrapping？？？？

seL4_IPCBuffer结构体中，第n个如果是unwrapped，那么就在接收方相应的槽中的位置放入badge，内核设置tag中的第n bit位标记为unwrapped，cap本身不会被发送。

非unwrapped则要复制发送。

sel4允许cap的接收者（同时也是这个cap的发送者）自定义cap value而不是用新名称，这种方式叫unwrapped。如果传送的cap是endpoint cap，接收方是这个endpoint cap的创建者。

![image-20220317213259231](images/3.16-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/image-20220317213259231.png)

[Genode - Genode on seL4 - IPC and virtual memory](https://genode.org/documentation/articles/sel4_part_2)。

#### seL4_MessageInfo_t 

seL4_MessageInfo_t 包含：

* length 发送的cap数量
* extraCaps 
* capsUnwrapped 希望接收该类型cap
* label

![image-20220317215617001](images/3.16-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/image-20220317215617001.png)

#### Badges

发送方可能发送endpoint的badge。endpoint可以通过seL4_CNode_Mint或seL4_CNode_Mutate加上标记，一旦被标记，这个badge将被传递给用该endpoint传递消息的任何接收方。

sel4_Recv不理解。

#### Fastpath

内核中经过高度优化的路径，满足下列条件才能使用：

- `seL4_Call` or `seL4_ReplyRecv` 的调用
- 数据正好能装入 `seL4_FastMessageRegisters` 寄存器.
- 进程必须有合法的地址空间.
- 不能传送任何cap.
- 不存在比IPC非阻塞线程的优先级更高的线程可以运行

### Exercises

badge类似于让服务器记录客户端的通信endpoint。客户端拿到badge进行通信。

## Notifications

### Background

允许进程彼此发送异步信号，主要用于中断处理和共享数据缓冲区的同步访问。

#### Notification objects

在notification cap的调用中发送和接收信号。notification对象包含：①信号量二进制数组的notification word，支持seL4_Signal() 和seL4_Wait()；②等待接收通知的TCB队列。

notification可以被badge，类似于endpoint。

seL4_Signal()：设置notification word，用发送方的badge按位与，因此word中可能有多个位置1，即多个sender发送了信号。它会解除第一个等待线程的阻塞状态。如果发送方的cap未badge，则只是唤醒第一个等待信号的线程。

seL4_Wait()：调用该函数时，如果当前notification word是0，就阻塞该线程。如果notification word非0，就返回notification word然后再次将notification word设为0。

seL4_Poll()：工作原理与Wait类似，只不过如果notification word是0，就返回，不阻塞。

当seL4_Signal()被调用时，如果有线程排队等待notification word，则等待队列的第一个线程被唤醒，接收这个notification。其他线程继续等待直到下次notification信号到来。

绑定notification：notification对象与TCB可以用seL4_TCB_BindNotification()一对一绑定。绑定后，即使接收线程在endpoint上接收IPC，信号量也能发送给该接收线程。需要检查badge值来确定收到的内容是IPC还是notification，保留特殊的badge来绑定notification，从而与endpoint badge区别开。一旦notification被绑定，唯一执行wait的线程叫做绑定线程。

该对象3状态：

* waiting：有TCB排队等待信号。

* Active：TCB已经向这个notification发出信号

* Idle：没有TCB排队，也没有TCB向这个对象发出信号。

##### Signalling

seL4_Signal，有任务向notification对象发出信号，取决于notification对象状态：

* Idle：数据字被设置为cap的badge，badge用于发送信号，notification转变为active
* Active：用来发送信号的badge与notification数据字按位或。
* Waiting：队列头部的tcb被唤醒，badge发送给它。如果队列为空，notification对象转变成idle

##### waiting

用函数seL4_wait，任务可以在notification上等待

* idle：TCB排队，进入waiting。
* active：tcb能接收数据字，数据字被设置为0，notification转变为idle。
* waiting：TCB被附加到队列中。

##### polling

seL4_Poll用于轮询，无论状态如何都会立即返回，seL4_wait的非阻塞版本。

### Interrupts and IPC

notification对象可以接收中断信号，也可以绑定到TCB，那么信号和IPC可以由同一个thread接收完成。

### Exercises

用notification和共享内存进行基本的生产者消费者设置。2个生产者，1个消费者。每个生产者与消费者共享一片缓存。消费者从两个生产者那里处理数据。

seL4_X86_Page_Map（）

![image-20220320102859511](images/3.17-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/image-20220320102859511.png)

## Interrupts

### Background

#### IRQControl

根任务特有的单独cap：seL4_CapIRQControl，系统中所有irq 号的cap都可以由他派生，这个cap也可以在cnode和cslot之间移动，但不能被复制。撤销该cap会导致所有irq number的cap删除。

#### IRQHandlers

IRQHandlers的cap可以访问单独的irq，并且是标准seL4的cap，可以移动或复制。IRQHandlers通过调用IRQControl cap相关函数生成，需要指定架构相关参数。

seL4_IRQControl_Get（）的参数：

* irq 的cap，给你权限来调用。
* 想要处理的irq
* cnode的cap
* cslot
* bit数量深度。

还有很多系统调用来获取irq的cap，与硬件相关，包括：

- [`seL4_IRQControl_GetIOAPIC`](https://docs.sel4.systems/ApiDoc.html#get-io-apic) (x86)
- [`seL4_IRQControl_GetMSI`](https://docs.sel4.systems/ApiDoc.html#get-msi) (x86)
- [`seL4_IRQControl_GetTrigger`](https://docs.sel4.systems/ApiDoc.html#gettrigger) (ARM)

#### Receiving interrupts

接收中断，需要注册notification object的cap，还需要irq handler的cap。

seL4_IRQHandler_SetNotification（）：

注册之后，中断发生时，中断信号会传递到notification对象。同一个notification对象上可以有多个中断事件，需要为每一个绑定到相应irq handler的notification cap设置badge。中断到达时，相应irq handler对应的notification cap的badge就和notification word按位与。

中断可以用seL4_Poll轮询，或seL4_wait等待。它们都会返回对应notification object的数据字作为badge传送过来，然后清零数据字。

seL4_IRQHandler_Clear（）：取消notification与irq handler的绑定。

#### Handling interrupts

一旦中断接收并被处理掉，可以用irq handler的seL4_IRQHandler_Ack函数取消屏蔽中断。如果IRQ到达，seL4不再进一步发出中断直到irq handler被确认。

### Exercises

timer.c 时间驱动程序和远程过程调用服务器。

client.c 发出单独的请求。

在TTC0_TIMER1_IRQ 中定时器驱动程序发出中断。

## Fault handling

### Background: What is a fault, and what is a fault handler?

错误处理程序是CPU在当前线程运行时，为了纠正错误，跳入的单独的指令流，CPU还可以重新调回之前的线程指令流。

seL4中，错误被建模为单独的程序员指定的故障处理程序线程。在单核中，故障通常不会传递给用户空间处理程序，而是由单核本身处理。

在不纠正异常的情况下，恢复故障线程的执行将无限地重新触发故障，直到异常被清除。

### Thread faults vs other sources of faults

* CPU遇到指令流异常时自身产生的Fault events。又名“处理器异常”
* 某些硬件异常（例如机器检查或不可屏蔽中断）的情况下由硬件生成的Fault events。
* seL4内核在当前线程遇到异常时产生的Fault events。

本教程只关注 seL4 内核生成的故障事件。将它们称为“线程错误”以减少歧义。

### How does thread fault handling work?

在 seL4 中，产生线程故障时，内核将阻止故障线程的执行，并尝试通过与该线程关联的endpoint（“fault handler” endpoint）传递消息。

“fault handler” endpoint 的特殊之处是一个线程只能拥有一个这种endpoint。

在“fault handler” endpoint的另一端侦听的线程称为“fault handler”。内核期望fault handler纠正故障线程的异常，然后告诉内核何时可以安全地再次尝试执行故障线程。

为了告诉内核恢复执行错误线程，错误处理程序可以：

* 在“fault handler” endpoint上调用 seL4_Reply()，并确保 seL4_MessageInfo_t 标记中的label设置为 0。
* 使用 seL4_TCB_Resume() 明确告诉内核继续执行故障线程。

如果处理程序在回复消息中设置了消息寄存器，内核可能会将其解释为有意义的东西：一些错误回复接受参数。有关所有故障的回复消息格式，请参见 seL4 手册

如果故障处理程序没有正确纠正故障线程中的异常，恢复故障线程只会导致内核重新生成故障。

### Reasons for thread faults:

线程错误可能由不同的原因而产生。当发生故障时，内核会将描述故障原因的信息作为 IPC 消息传递。

* Cap fault：由于无效的cap 访问而触发的故障。
* VM fault：由不连贯的页表状态或线程不正确的内存访问触发的故障。
* Unknown Syscall fault：执行内核未知的系统调用调用。
* Debug fault：当断点、观察点或单步调试事件发生时触发。

MCS 内核还添加了以下故障类型。

* Timeout fault：当线程消耗其所有预算并且在当前期间仍有进一步执行时触发。

### Thread fault messages

当产生故障时，内核将通过故障端点传递 IPC 消息。该 IPC 消息包含：为什么发生故障，以及可能帮助故障处理程序纠正异常的故障上下文信息。

每个异常都有自己的消息格式，因为描述每个异常所需的信息会有所不同。有关 seL4 内核针对每个故障异常发送的 IPC 消息的内容的更多信息，请参阅 seL4 手册。

本教程的其余部分将尝试教读者如何接收和处理 seL4 线程错误。

### Setting up a fault endpoint for a thread

在故障消息传递到故障端点的场景中，内核充当 IPC“发送者”，故障处理程序充当接收者。

这意味着分发fault endpoint object的cap时，必须将一个cap提供给内核，另一个cap提供给处理程序。

#### Kernel end vs handler end

程序员在配置 TCB 时，为线程指定故障处理程序的cap。因此，可以在内核的fault endpoint cap s上设置标记。

当内核使用带标记的 endpoint cap发送故障 IPC 消息时，该标记被传递给接收者，就像其他带有标记的endpoint cap的IPC通信一样。

敏锐的读者可能已经意识到，这意味着内核fault endpoint cap的标记可用于区分来自不同故障线程的故障消息，以便单个fault handler可以处理来自多个线程的故障。请参阅 IPC 教程，了解fault handler的工作原理。

#### Differences between MCS and Master kernel

内核被分配fault endpoint的cap的方式有细微差别。

告诉内核某线程的fault endpoint，调用 seL4_TCB_SetSpace()

### Exercises

本教程有一个由 CapDL 加载程序设置的地址空间，包含两个共享相同 CSpace 的线程。其中一个线程是故障处理程序，而另一个则触发虚拟内存故障。教程包括：

* 为faulting thread 做badge和配置故障处理程序。
* 让故障线程触发线程故障
* 在故障处理程序中处理故障。
* 恢复故障线程的执行。

#### Description of the tutorial program

本教程以不同虚拟地址空间中的两个线程为特色。一个线程是“故障者”，另一个是“处理程序”。故障者将产生一个故障，处理程序将“处理”它。

为了让handler处理故障，handler必须设置一个fault-handling endpoint，并告诉内核将faulter线程生成的所有故障 IPC 消息发送给handler。

但是，我们必须确保只有在handler线程设置了fault-handling endpoint并准备好从内核接收故障 IPC 消息后才会触发故障。

如果faulter线程产生故障并且没有线程来处理 IPC 消息，内核将简单地挂起faulter线程。

出于这个原因，我们让faulter线程通过一个endpoint调用 seL4_call() 向handler线程发消息，告诉它handler应该将fault handling endpoint cap放入哪个槽。handler设置处理程序端点后，handler将 seL4_Reply() 发送给faulter，以告知其handler已准备好处理故障 IPC 消息。

之后，我们在 faulter 中触发一个错误，在 handler 中处理错误，然后恢复 faulter，这就是练习的结束。

#### Setting up the endpoint to be used for thread fault IPC messages.

第一个练习是为故障者的 TCB 配置fault endpoint。本练习旨在实现两个学习成果：

* 说明给内核的endpoint 的end可以被badge，当内核发送故障 IPC 消息时将返回该标记值。
* 在向内核告知fault endpoint时，请解释主内核和 MCS 内核之间的区别。

现在faulter被阻塞在一个端点上，等待handler告诉它把 fault handler endpoint放在它自己的（faulter的）CSpace（用于主内核）中的什么位置。

要设置fault handler endpoint，我们将首先标记它，以便当内核向我们发送故障 IPC 消息时，我们将能够识别故障者。故障处理程序可以处理来自多个线程的故障，因此标记使处理程序能够识别他们正在处理的故障。

seL4_CNode_Mint

![image-20220320203340361](images/3.17-TODO-porting%E4%B8%8Etutorials%E9%83%A8%E5%88%86.assets/image-20220320203340361.png)

#### Finding out information about the generated thread fault:

在线程故障IPC消息中，内核将发送有关故障的信息，包括访问触发线程故障的能力地址。 seL4 手册详细介绍了 IPC 缓冲区中的哪些消息寄存器包含有关故障的信息，如果您愿意，libsel4 源代码也有确切的代码值。

在我们的示例中，我们的示例代码生成了一个 Cap Fault，因此根据 seL4 手册，我们可以使用 IPC 消息中的偏移量 seL4_CapFault_Addr 找到 cap 故障地址，正如您在上面的代码片段中看到的那样。













